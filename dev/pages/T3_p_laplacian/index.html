<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · Gridap DD29 Workshop</title><meta name="title" content="- · Gridap DD29 Workshop"/><meta property="og:title" content="- · Gridap DD29 Workshop"/><meta property="twitter:title" content="- · Gridap DD29 Workshop"/><meta name="description" content="Documentation for Gridap DD29 Workshop."/><meta property="og:description" content="Documentation for Gridap DD29 Workshop."/><meta property="twitter:description" content="Documentation for Gridap DD29 Workshop."/><meta property="og:url" content="https://gridap.github.io/GridapDD29Workshop/pages/T3_p_laplacian/"/><meta property="twitter:url" content="https://gridap.github.io/GridapDD29Workshop/pages/T3_p_laplacian/"/><link rel="canonical" href="https://gridap.github.io/GridapDD29Workshop/pages/T3_p_laplacian/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Gridap DD29 Workshop logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Gridap DD29 Workshop</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../software_install/">Software installation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gridap/GridapDD29Workshop" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gridap/GridapDD29Workshop/blob/main/src/T3_p_laplacian.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Problem-statement"><a class="docs-heading-anchor" href="#Problem-statement">Problem statement</a><a id="Problem-statement-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-statement" title="Permalink"></a></h2><p>The goal of this tutorial is to solve a nonlinear PDE in Gridap. For the sake of simplicity, we consider the <span>$p$</span>-Laplacian equation as the model problem. Specifically, the PDE  we want to solve is: find the scalar-field <span>$u$</span> such that</p><p class="math-container">\[\left\lbrace
\begin{aligned}
-\nabla \cdot \left( |\nabla u|^{p-2} \ \nabla u \right) = f\ &amp;\text{ in }\ \Omega,\\
u = 0 \ &amp;\text{ on } \ \Gamma_0,\\
u = g \ &amp;\text{ on } \ \Gamma_g,\\
 n \cdot \left( |\nabla u|^{p-2}\ \nabla u \right)= 0 \ &amp;\text{ on } \ \Gamma_{\rm N},
\end{aligned}
\right.\]</p><p>with <span>$p&gt;2$</span>. The computational domain <span>$\Omega$</span> is the one depicted in next figure. We want to solve the Poisson equation on the 3D domain depicted in next figure with Dirichlet and Neumann boundary conditions. We impose homogeneous Dirichlet and homogeneous Neumann boundary conditions on <span>$\Gamma_0$</span> and <span>$\Gamma_{\rm N}$</span>  respectively, and inhomogeneous Dirichlet conditions on <span>$\Gamma_g$</span>. The Dirichlet boundaries <span>$\Gamma_0$</span> and <span>$\Gamma_g$</span> are defined as the closure of the green and blue surfaces in next figure respectively, whereas the Neumann boundary is <span>$\Gamma_{\rm N}\doteq\partial\Omega \setminus (\Gamma_0\cup\Gamma_g)$</span>. In this example, we consider the values <span>$p=3$</span>, <span>$f=1$</span>, and <span>$g=2$</span>.</p><p><img src="../../assets/p_laplacian/model.png" alt/></p><h2 id="Numerical-scheme"><a class="docs-heading-anchor" href="#Numerical-scheme">Numerical scheme</a><a id="Numerical-scheme-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-scheme" title="Permalink"></a></h2><p>We discretize the problem with conforming Lagrangian FE spaces. For this formulation, the nonlinear weak form reads: find <span>$u\in U_g$</span> such that <span>$[r(u)](v) = 0$</span> for all <span>$v\in V_0$</span>. As in previous tutorials, the space <span>$U_g$</span> is the set of functions in <span>$H^1(\Omega)$</span> that fulfill the Dirichlet boundary conditions, whereas <span>$V_0$</span> is composed by functions in <span>$H^1(\Omega)$</span> that vanish at the Dirichlet boundary. The weak residual <span>$r(u)$</span> evaluated at a function  <span>$u\in U_g$</span> is the linear form defined as</p><p class="math-container">\[[r(u)](v) \doteq \int_\Omega \nabla v \cdot \left( |\nabla u|^{p-2}\ \nabla u \right) \ {\rm d}\Omega - \int_\Omega v\ f \ {\rm d}\Omega.\]</p><p>In order to solve this nonlinear weak equation, we consider a Newton-Raphson method, which is associated with a linearization of the problem in an arbitrary direction <span>$\delta u\in V_0$</span>, namely <span>$[r(u+\delta u)](v)\approx [r(u)](v) + [j(u)](\delta u,v)$</span>. In previous formula,  <span>$j(u)$</span> is the Jacobian evaluated at <span>$u\in U_g$</span>, which is the bilinear form</p><p class="math-container">\[[j(u)](\delta u,v) = \int_\Omega \nabla v \cdot \left( |\nabla u|^{p-2}\ \nabla \delta u \right) \ {\rm d}\Omega + (p-2) \int_\Omega \nabla v \cdot \left(  |\nabla u|^{p-4} (\nabla u \cdot \nabla \delta u) \nabla u  \right) \ {\rm d}\Omega.\]</p><p>Note that the solution of this nonlinear PDE with a Newton-Raphson method, will require to discretize both the residual <span>$r$</span> and the Jacobian <span>$j$</span>. In Gridap, this is done by following an approach similar to the one already shown in previous tutorials for discretizing the bilinear and linear forms associated with a linear FE problem. The specific details are discussed now.</p><h2 id="Discrete-model"><a class="docs-heading-anchor" href="#Discrete-model">Discrete model</a><a id="Discrete-model-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-model" title="Permalink"></a></h2><p>As in previous tutorials, the first step to solve the PDE is to load a discretization of the computational domain. In this case, we load the model from the same file as in the first tutorial</p><pre><code class="language-julia hljs">using Gridap
using DrWatson
model = DiscreteModelFromFile(&quot;meshes/poisson.json&quot;)</code></pre><p>As stated before, we want to impose Dirichlet boundary conditions on <span>$\Gamma_0$</span> and <span>$\Gamma_g$</span>,  but none of these boundaries is identified in the model. E.g., you can easily see by writing the model in vtk format</p><pre><code class="language-julia hljs">writevtk(model,&quot;model&quot;)</code></pre><p>and by opening the file <code>&quot;model_0&quot;</code> in ParaView that the boundary identified as <code>&quot;sides&quot;</code> only includes the vertices in the interior of <span>$\Gamma_0$</span>, but here we want to impose Dirichlet boundary conditions in the closure of <span>$\Gamma_0$</span>, i.e., also on the vertices on the contour of <span>$\Gamma_0$</span>. Fortunately, the objects on the contour of <span>$\Gamma_0$</span> are identified  with the tag <code>&quot;sides_c&quot;</code> (see next figure). Thus, the Dirichlet boundary <span>$\Gamma_0$</span> can be built as the union of the objects identified as <code>&quot;sides&quot;</code> and <code>&quot;sides_c&quot;</code>.</p><p><img src="../../assets/p_laplacian/sides_c.png" alt/></p><p>Gridap provides a convenient way to create new object identifiers (referred to as &quot;tags&quot;) from existing ones. First, we need to extract from the model, the object that holds the information about the boundary identifiers (referred to as <code>FaceLabeling</code>):</p><pre><code class="language-julia hljs">labels = get_face_labeling(model)</code></pre><p>Then, we can add new identifiers (aka &quot;tags&quot;) to it. In the next line, we create a new tag called <code>&quot;diri0&quot;</code> as the union of the objects identified as <code>&quot;sides&quot;</code> and <code>&quot;sides_c&quot;</code>, which is precisely what we need to represent the closure of the Dirichlet boundary <span>$\Gamma_0$</span>.</p><pre><code class="language-julia hljs">add_tag_from_tags!(labels,&quot;diri0&quot;,[&quot;sides&quot;, &quot;sides_c&quot;])</code></pre><p>We follow the same approach to build a new identifier for the closure of the Dirichlet boundary <span>$\Gamma_g$</span>. In this case, the boundary is expressed as the union of the objects identified with the tags <code>&quot;circle&quot;</code>, <code>&quot;circle_c&quot;</code>, <code>&quot;triangle&quot;</code>, <code>&quot;triangle_c&quot;</code>, <code>&quot;square&quot;</code>, <code>&quot;square_c&quot;</code>. Thus, we create a new tag for  <span>$\Gamma_g$</span>, called <code>&quot;dirig&quot;</code> simply as follows:</p><pre><code class="language-julia hljs">add_tag_from_tags!(labels,&quot;dirig&quot;,
  [&quot;circle&quot;,&quot;circle_c&quot;, &quot;triangle&quot;, &quot;triangle_c&quot;, &quot;square&quot;, &quot;square_c&quot;])</code></pre><h2 id="FE-Space"><a class="docs-heading-anchor" href="#FE-Space">FE Space</a><a id="FE-Space-1"></a><a class="docs-heading-anchor-permalink" href="#FE-Space" title="Permalink"></a></h2><p>Now, we can build the FE space by using the newly defined boundary tags.</p><pre><code class="language-julia hljs">reffe = ReferenceFE(lagrangian,Float64,1)
V0 = TestFESpace(model,reffe,conformity=:H1,labels=labels,dirichlet_tags=[&quot;diri0&quot;, &quot;dirig&quot;])</code></pre><p>The construction of this space is essentially the same as in the first tutorial (we build a continuous scalar-valued Lagrangian interpolation of first order). However, we also pass here the <code>labels</code> object (that contains the newly created boundary tags). From this FE space, we define the trial FE spaces</p><pre><code class="language-julia hljs">g = 1
Ug = TrialFESpace(V0,[0,g])</code></pre><h2 id="Nonlinear-FE-problem"><a class="docs-heading-anchor" href="#Nonlinear-FE-problem">Nonlinear FE problem</a><a id="Nonlinear-FE-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-FE-problem" title="Permalink"></a></h2><p>At this point, we are ready to build the nonlinear FE problem. To this end, we need to define the weak residual and also its corresponding Jacobian. This is done following a similar procedure to the one considered in previous tutorials to define the bilinear and linear forms associated with linear FE problems. We first need to define the usual objects for numerical integration:</p><pre><code class="language-julia hljs">degree=2
Ω = Triangulation(model)
dΩ = Measure(Ω,degree)</code></pre><p>On the one hand, the weak residual is built as follows</p><pre><code class="language-julia hljs">const p = 3
flux(∇u) = norm(∇u)^(p-2) * ∇u
f(x) = 1
res(u,v) = ∫( ∇(v)⊙(flux∘∇(u)) - v*f )*dΩ</code></pre><p>Function <code>res</code> is the one representing the integrand of the weak residual <span>$[r(u)](v)$</span>. The first argument of function <code>res</code> stands for the function <span>$u\in U_g$</span>, where the residual is evaluated, and the second argument stands for a generic test function <span>$v\in V_0$</span>.</p><p>On the other hand,  we (optionally) implement a function <code>jac</code> representing the Jacobian.</p><pre><code class="language-julia hljs">dflux(∇du,∇u) = (p-2)*norm(∇u)^(p-4)*(∇u⊙∇du)*∇u+norm(∇u)^(p-2)*∇du
jac(u,du,v) = ∫( ∇(v)⊙(dflux∘(∇(du),∇(u))) )*dΩ</code></pre><p>The first argument of function <code>jac</code> stands for function <span>$u\in U_g$</span>, where the Jacobian is evaluated. The second argument is a test function <span>$v\in V_0$</span>, and the third argument represents an arbitrary direction <span>$\delta u \in V_0$</span>.</p><p>We finally construct the nonlinear FE problem</p><pre><code class="language-julia hljs">op = FEOperator(res,jac,Ug,V0)</code></pre><p>Here, we have constructed an instance of <code>FEOperator</code>, which is the type that represents a general nonlinear FE problem in Gridap. The constructor takes the functions representing the weak residual and Jacobian, and the test and trial spaces. If only the function for the residual is provided, the Jacobian is computed internally with automatic differentiation:</p><pre><code class="language-julia hljs">op_AD = FEOperator(res,Ug,V0)</code></pre><h2 id="Nonlinear-solver-phase"><a class="docs-heading-anchor" href="#Nonlinear-solver-phase">Nonlinear solver phase</a><a id="Nonlinear-solver-phase-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-solver-phase" title="Permalink"></a></h2><p>We have already built the nonlinear FE problem. Now, the remaining step is to solve it. In Gridap, nonlinear (and also linear) FE problems can be solved with instances of the type <code>FESolver</code>.</p><p>We construct an instance of <code>FESolver</code> as follows:</p><pre><code class="language-julia hljs">using LineSearches: BackTracking
nls = NLSolver(
  show_trace=true, method=:newton, linesearch=BackTracking())
solver = FESolver(nls)</code></pre><p>Note that the <code>NLSolver</code> function used above internally calls the <code>nlsolve</code> function of the <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve</a> package with the provided key-word arguments. Thus, one can use any of the nonlinear methods available via the function <code>nlsolve</code> to solve the nonlinear FE problem. Here, we have selected a Newton-Raphson method with a back-tracking line-search from the <a href="https://github.com/JuliaNLSolvers/LineSearches.jl">LineSearches</a> package.</p><p>We are finally in place to solve the nonlinear FE problem. The initial guess is a <code>FEFunction</code>, which we build from a vector of random (free) nodal values:</p><pre><code class="language-julia hljs">import Random
Random.seed!(1234)
x = rand(Float64,num_free_dofs(Ug))
uh0 = FEFunction(Ug,x)
uh, = solve!(uh0,solver,op)</code></pre><p>We finish this tutorial by writing the computed solution for visualization (see next figure).</p><pre><code class="language-julia hljs">writevtk(Ω,datadir(&quot;p_laplacian&quot;),cellfields=[&quot;uh&quot;=&gt;uh])</code></pre><p><img src="../../assets/p_laplacian/sol-plap.png" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Friday 13 June 2025 05:59">Friday 13 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
