<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>T1 poisson · Gridap DD29 Workshop</title><meta name="title" content="T1 poisson · Gridap DD29 Workshop"/><meta property="og:title" content="T1 poisson · Gridap DD29 Workshop"/><meta property="twitter:title" content="T1 poisson · Gridap DD29 Workshop"/><meta name="description" content="Documentation for Gridap DD29 Workshop."/><meta property="og:description" content="Documentation for Gridap DD29 Workshop."/><meta property="twitter:description" content="Documentation for Gridap DD29 Workshop."/><meta property="og:url" content="https://gridap.github.io/GridapDD29Workshop/pages/T1_poisson/"/><meta property="twitter:url" content="https://gridap.github.io/GridapDD29Workshop/pages/T1_poisson/"/><link rel="canonical" href="https://gridap.github.io/GridapDD29Workshop/pages/T1_poisson/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Gridap DD29 Workshop logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Gridap DD29 Workshop</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../software_install/">Software installation</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>T1 poisson</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Numerical-scheme"><span>Numerical scheme</span></a></li><li><a class="tocitem" href="#Setup"><span>Setup</span></a></li><li><a class="tocitem" href="#Discrete-model"><span>Discrete model</span></a></li><li><a class="tocitem" href="#Approximation-spaces"><span>Approximation spaces</span></a></li><li><a class="tocitem" href="#Numerical-integration"><span>Numerical integration</span></a></li><li><a class="tocitem" href="#Weak-form"><span>Weak form</span></a></li><li><a class="tocitem" href="#FE-Problem"><span>FE Problem</span></a></li><li><a class="tocitem" href="#Solver-phase"><span>Solver phase</span></a></li><li><a class="tocitem" href="#Convergence-analysis"><span>Convergence analysis</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../T2_transient_poisson/">T2 transient poisson</a></li><li><a class="tocitem" href="../T3_p_laplacian/">T3 p laplacian</a></li><li><a class="tocitem" href="../T4_stokes/">T4 stokes</a></li></ul></li><li><span class="tocitem">Exercises</span><ul><li><a class="tocitem" href="../E1_linear_elasticity/">E1 linear elasticity</a></li><li><a class="tocitem" href="../E2_navier_stokes/">E2 navier stokes</a></li><li><a class="tocitem" href="../E3_transient_navier_stokes/">E3 transient navier stokes</a></li></ul></li><li><a class="tocitem" href="../../going_further/">Going further</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>T1 poisson</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>T1 poisson</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gridap/GridapDD29Workshop" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gridap/GridapDD29Workshop/blob/main/src/T1_poisson.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Problem-statement"><a class="docs-heading-anchor" href="#Problem-statement">Problem statement</a><a id="Problem-statement-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-statement" title="Permalink"></a></h2><p>In this first tutorial, we provide an overview of a complete simulation pipeline in Gridap: from the construction of the FE mesh to the visualization of the computed results. To this end, we consider a simple model problem: the Poisson equation.</p><p>We want to solve the Poisson equation on the 3D cartesian domain <span>$[-\pi,\pi]\times[-\pi/2,\pi/2]\times[0,1]$</span> with Dirichlet and Neumann boundary conditions. Neumann boundary conditions are applied on <span>$\Gamma_{\rm N} = \{ z = 0 \} \cup \{ z = 1 \}$</span>, i.e the bottom and top boundaries. Dirichlet boundary conditions are applied everywhere else, i.e <span>$\Gamma_{\rm D} = \{ x = -\pi \} \cup \{ x = \pi \} \cup \{ y = -\pi/2 \} \cup \{ y = \pi/2 \}$</span>.</p><p>Formally, the problem to solve is: find the scalar field <span>$u$</span> such that</p><p class="math-container">\[\left\lbrace
\begin{aligned}
-\Delta u = f  \ &amp;\text{ in } \ \Omega,\\
u = g \ &amp;\text{ on }\ \Gamma_{\rm D},\\
 n \cdot \nabla u = h \ &amp;\text{ on }\  \Gamma_{\rm N},\\
\end{aligned}
\right.\]</p><p>with <span>$n$</span> being  the outwards unit normal vector to the Neumann boundary <span>$\Gamma_{\rm N}$</span>. In this tutorial, we will try to recover an analytical solution <span>$u_0(x,y,z) = {\rm cos}(x)\ {\rm sin}(y+π)$</span> and analyze the convergence rates of our numerical approximation.</p><h2 id="Numerical-scheme"><a class="docs-heading-anchor" href="#Numerical-scheme">Numerical scheme</a><a id="Numerical-scheme-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-scheme" title="Permalink"></a></h2><p>To solve this PDE, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1] for specific details on this formulation). The weak form associated with this formulation is: find <span>$u\in U$</span> such that $ a(u,v) = l(v) $ for all <span>$v\in V$</span>, where <span>$U$</span> and <span>$V$</span> are the subset of functions in <span>$H^1(\Omega)$</span> that fulfill the Dirichlet boundary condition <span>$g$</span> and <span>$0$</span> respectively. The bilinear and linear forms for this problems are</p><p class="math-container">\[  a(u,v) \doteq \int_{\Omega} \nabla v \cdot \nabla u \ {\rm d}\Omega, \quad l(v) \doteq \int_{\Omega} v\ f  \ {\rm  d}\Omega + \int_{\Gamma_{\rm N}} v\ h \ {\rm d}\Gamma_{\rm N}.\]</p><p>The problem is solved numerically by approximating the spaces <span>$U$</span> and <span>$V$</span> by their discrete counterparts associated with a FE mesh of the computational domain <span>$\Omega$</span>. As we have anticipated, we consider standard conforming Lagrangian FE spaces for this purpose.</p><p>The implementation of this numerical scheme in Gridap is done in a user-friendly way thanks to the abstractions provided by the library. As it will be seen below, all the mathematical objects involved in the definition of the discrete weak problem have a correspondent representation in the code.</p><h2 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h2><p>The step number 0 in order to solve the problem is to load the Gridap library in the code. For convenience, we will also be using <code>DrWatson.jl</code>. If you have configured your Julia environment properly, it is simply done with the line:</p><pre><code class="language-julia hljs">using Gridap
using DrWatson</code></pre><p>We define the analytical solution we will try to retrieve as follows:</p><pre><code class="language-julia hljs">u₀(x)  = cos(x[1])*sin(x[2]+π)
∇u₀(x) = VectorValue(-sin(x[1])*sin(x[2]+π),cos(x[1])*cos(x[2]+π),0.0)
Δu₀(x) = -2.0*cos(x[1])*sin(x[2]+π)</code></pre><p>We also define the other functions involved in the problem statement:</p><pre><code class="language-julia hljs">f(x) = -Δu₀(x)
g(x) = u₀(x)
h(x) = 0.0      # ∇u₀ ⋅ n_Γ = ∇u₀ ⋅ ± e₃ = 0</code></pre><h2 id="Discrete-model"><a class="docs-heading-anchor" href="#Discrete-model">Discrete model</a><a id="Discrete-model-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-model" title="Permalink"></a></h2><p>As in any FE simulation, we need a discretization of the computational domain (i.e., a FE mesh). All geometrical data needed for solving a FE problem is provided in Gridap by types inheriting from the abstract type <code>DiscreteModel</code>. In our particular case, we will create a <code>CartesianDiscreteModel</code> of the computational domain <span>$\Omega = [-\pi,\pi]\times[-\pi/2,\pi/2]\times[0,1]$</span> with a resolution <span>$n_C=(n_x,n_y,n_z)$</span></p><pre><code class="language-julia hljs">domain = (-π,π,-π/2,π/2,0,1)
nC     = (100,40,5)
model  = CartesianDiscreteModel(domain,nC)</code></pre><p>By construction, a <code>CartesianDiscreteModel</code> associates with labels every vertex, edge and facet of the model to its parent corner, edge, facet or interior of the grid&#39;s bounding box. Label numbering follows the increasing lexicographic order.</p><p>We use this default order to set up the BCs as follows. For convenience, we create two new boundary tags, namely <code>&quot;dirichlet&quot;</code> and <code>&quot;neumann&quot;</code>.</p><p>Gridap provides a convenient way to create new object identifiers (referred to as &quot;tags&quot;) from existing ones. First, we need to extract from the model, the object that holds the information about the boundary identifiers (referred to as <code>FaceLabeling</code>):</p><pre><code class="language-julia hljs">labels = get_face_labeling(model)</code></pre><p>Then, we can add new identifiers (aka &quot;tags&quot;) to it. In the next line, we create new tags called <code>&quot;dirichlet&quot;</code> and <code>&quot;neumann&quot;</code> combining the default labels of the model to represent <span>$\Gamma_D$</span> and <span>$\Gamma_N$</span> respectively.</p><pre><code class="language-julia hljs">add_tag_from_tags!(labels,&quot;neumann&quot;,[&quot;tag_21&quot;,&quot;tag_22&quot;])
add_tag_from_tags!(labels,&quot;dirichlet&quot;,[&quot;tag_23&quot;,&quot;tag_24&quot;,&quot;tag_25&quot;,&quot;tag_26&quot;])</code></pre><p>Note the usage of <code>add_tag_from_tags!</code> to construct new boundary tags gathering lower-level tags.</p><h2 id="Approximation-spaces"><a class="docs-heading-anchor" href="#Approximation-spaces">Approximation spaces</a><a id="Approximation-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Approximation-spaces" title="Permalink"></a></h2><pre><code class="language-julia hljs">order = 1
reffe = ReferenceFE(lagrangian,Float64,order)
V = TestFESpace(model,reffe;conformity=:H1,dirichlet_tags=&quot;dirichlet&quot;)</code></pre><p>Here, we have used the <code>TestFESpace</code> constructor, which constructs a particular FE space (to be used as a test space) from a set of options described as positional and key-word arguments. The first positional argument is the model on top of which we want to build the space. The second positional argument contains information about the type of FE interpolation (the reference FE in this case). With <code>ReferenceFE(lagrangian,Float64,order)</code> We select a scalar-valued Lagrangian reference FE of order 1, where the value of the shape functions will be represented with  64-bit floating point numbers. With the key-word argument <code>conformity</code> we define the regularity of the interpolation at the boundaries of the cells in the mesh. Here, we use <code>conformity=:H1</code>, which means that the resulting interpolation space is a subset of <span>$H^1(\Omega)$</span> (i.e., continuous shape functions). On the other hand, we pass the identifiers of the Dirichlet boundary via the <code>dirichlet_tags</code> argument. Since this is a test space, the corresponding shape functions vanishes at the Dirichlet boundary.</p><p>Once the space <span>$V$</span> is discretized in the code, we proceed with the approximation of the trial space <span>$U$</span>.</p><pre><code class="language-julia hljs">U = TrialFESpace(V,g)</code></pre><p>To this end, we have used the <code>TrialFESpace</code> constructors. Note that we have passed a function representing the value of the Dirichlet boundary condition, when building the trial space (here our analytical solution).</p><h2 id="Numerical-integration"><a class="docs-heading-anchor" href="#Numerical-integration">Numerical integration</a><a id="Numerical-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-integration" title="Permalink"></a></h2><p>Once we have built the interpolation spaces, the next step is to set up the machinery to perform the integrals in the weak form numerically. Here, we need to compute integrals on the interior of the domain <span>$\Omega$</span> and on the Neumann boundary <span>$\Gamma_{\rm N}$</span>. In both cases, we need two main ingredients. We need to define an integration mesh (i.e. a triangulation of the integration domain), plus a Gauss-like quadrature in each of the cells in the triangulation. In Gridap, integration meshes are represented by types inheriting from the abstract type <code>Triangulation</code>. For integrating on the domain <span>$\Omega$</span>, we build the following triangulation and the corresponding Lebesgue measure, which will allow to write down integrals in a syntax similar to the usual mathematical notation.</p><pre><code class="language-julia hljs">degree = order*2
Ω  = Triangulation(model)
dΩ = Measure(Ω,degree)</code></pre><p>Here, we build a triangulation from the cells of the model and build (an approximation of) the Lebesgue measure using a quadrature rule of degree 2 in the cells of this triangulation. This is enough for integrating the corresponding terms of the weak form exactly for an interpolation of order 1.</p><p>On the other hand, we need a special type of triangulation, represented by the type <code>BoundaryTriangulation</code>, to integrate on the boundary. Essentially, a <code>BoundaryTriangulation</code> is a particular type of <code>Triangulation</code> that is aware of which cells in the model are touched by faces on the boundary. We build an instance of this type from the discrete model and the names used to identify the Neumann boundary as follows:</p><pre><code class="language-julia hljs">Γ   = BoundaryTriangulation(model,tags=&quot;neumann&quot;)
dΓ  = Measure(Γ,degree)</code></pre><p>In addition, we have created a quadrature of degree 2 on top of the cells in the triangulation for the Neumann boundary.</p><h2 id="Weak-form"><a class="docs-heading-anchor" href="#Weak-form">Weak form</a><a id="Weak-form-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-form" title="Permalink"></a></h2><p>With all the ingredients presented so far, we are ready to define the weak form. This is done by defining functions representing the bi-linear and linear forms:</p><pre><code class="language-julia hljs">a(u,v) = ∫( ∇(v)⋅∇(u) )*dΩ
l(v)   = ∫( v*f )*dΩ + ∫( v*h )*dΓ</code></pre><p>Note that by using the integral function <code>∫</code>, the Lebesgue measures <code>dΩ</code>, <code>dΓ</code>, and the gradient function <code>∇</code>, the weak form is written with an obvious relation with the corresponding mathematical notation.</p><h2 id="FE-Problem"><a class="docs-heading-anchor" href="#FE-Problem">FE Problem</a><a id="FE-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#FE-Problem" title="Permalink"></a></h2><p>At this point, we can build the FE problem that, once solved, will provide the numerical solution we are looking for. A FE problem is represented in Gridap by types inheriting from the abstract type <code>FEOperator</code> (both for linear and nonlinear cases). Since we want to solve a linear problem, we use the concrete type <code>AffineFEOperator</code>, i.e., a problem represented by a matrix and a right hand side vector.</p><pre><code class="language-julia hljs">op = AffineFEOperator(a,l,U,V)</code></pre><p>Note that the <code>AffineFEOperator</code> object representing our FE problem is built from the function <code>a</code> and <code>l</code> representing the weak form and test and trial FE spaces <code>V</code> and <code>U</code>.</p><p>We can also retrieve the matrix and the right hand side vector of the problem as follows:</p><pre><code class="language-julia hljs">A = get_matrix(op)
b = get_vector(op)</code></pre><h2 id="Solver-phase"><a class="docs-heading-anchor" href="#Solver-phase">Solver phase</a><a id="Solver-phase-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-phase" title="Permalink"></a></h2><p>We have constructed a FE problem, the last step is to solve it. In Gridap, FE problems are solved with types inheriting from the abstract type <code>FESolver</code>. Since this is a linear problem, we use a <code>LinearFESolver</code>:</p><pre><code class="language-julia hljs">ls = LUSolver()
solver = LinearFESolver(ls)</code></pre><p><code>LinearFESolver</code> objects are built from a given algebraic linear solver. In this case, we use a LU factorization. Now we are ready to solve the FE problem with the FE solver as follows:</p><pre><code class="language-julia hljs">uh = solve(solver,op)</code></pre><p>The <code>solve</code> function returns the computed numerical solution <code>uh</code>. This object is an instance of <code>FEFunction</code>, the type used to represent a function in a FE space. <code>FEFunction</code> is part of the <code>CellField</code> abstract type, which are objects that represent fields over a triangulated domain. We can inspect the result by writing it into a <code>vtk</code> file:</p><pre><code class="language-julia hljs">writevtk(Ω,datadir(&quot;poisson&quot;),cellfields=[&quot;uh&quot;=&gt;uh])</code></pre><p>which will generate a file named <code>poisson_sol.vtu</code> having a nodal field named <code>&quot;uh&quot;</code> containing the solution of our problem (see next figure).</p><p><img src="../../assets/poisson/fig_uh.png" alt/></p><p>Additionally, we can compute the L2 error of the numerical solution as follows:</p><pre><code class="language-julia hljs">dΩe  = Measure(Ω,degree*2)
e = uh - u₀
l2_error = sqrt(sum(∫(e⋅e)*dΩe))</code></pre><h2 id="Convergence-analysis"><a class="docs-heading-anchor" href="#Convergence-analysis">Convergence analysis</a><a id="Convergence-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-analysis" title="Permalink"></a></h2><p>One of the advantages of having an analytical solution is that we can compute the convergence rates of our numerical approximation. The first step is to define a driver by putting together all the steps described above. The driver takes two arguments: the number of cells in the <span>$x$</span> and <span>$y$</span> direction, <span>$n$</span>, and the order of the finite-element interpolation, <span>$p$</span>. It returns the L2 error of the numerical solution.</p><pre><code class="language-julia hljs">function driver(n,order)
  domain = (-π,π,-π/2,π/2,0,1)
  nC     = (n,n,1)
  model  = CartesianDiscreteModel(domain,nC)
  labels = get_face_labeling(model)
  add_tag_from_tags!(labels,&quot;dirichlet&quot;,[&quot;tag_21&quot;,&quot;tag_22&quot;])
  add_tag_from_tags!(labels,&quot;neumann&quot;,[&quot;tag_23&quot;,&quot;tag_24&quot;,&quot;tag_25&quot;,&quot;tag_26&quot;])

  reffe = ReferenceFE(lagrangian,Float64,order)
  V = TestFESpace(model,reffe;conformity=:H1,dirichlet_tags=&quot;dirichlet&quot;)

  U = TrialFESpace(V,g)
  degree = order*2+1
  Ω   = Triangulation(model)
  dΩ  = Measure(Ω,degree)
  Γ   = BoundaryTriangulation(model,tags=&quot;neumann&quot;)
  dΓ  = Measure(Γ,degree)

  a(u,v) = ∫( ∇(v)⋅∇(u) )*dΩ
  l(v)   = ∫( v*f )*dΩ + ∫( v*h )*dΓ
  op     = AffineFEOperator(a,l,U,V)
  ls     = LUSolver()
  solver = LinearFESolver(ls)
  uh = solve(solver,op)

  dΩe  = Measure(Ω,degree*2)
  e = uh - u₀
  return sqrt(sum(∫(e⋅e)*dΩe))
end</code></pre><p>We then run the driver for different values of <span>$n$</span> and <span>$p$</span>, saving the values of the L2 error for each configuration.</p><pre><code class="language-julia hljs">order_vec = [1,2]
n_vec = [10,20,40,80]
h_vec = map(n -&gt; 1/n, n_vec)

error = zeros((length(order_vec),length(n_vec)))
for (i,order) in enumerate(order_vec)
  for (j,n) in enumerate(n_vec)
    error[i,j] = driver(n,order)
  end
end</code></pre><p>Finally, we plot the results and compute the convergence rates.</p><pre><code class="language-julia hljs">using Plots
plt = plot(xlabel=&quot;log10(h)&quot;,ylabel=&quot;log10(L2 error)&quot;,grid=true)
for (i,e) in enumerate(eachrow(error))
  order = order_vec[i]
  dx = log10(h_vec[1]) - log10(h_vec[end])
  dy = log10(e[1]) - log10(e[end])
  slope = string(dy/dx)[1:4]
  plot!(plt,log10.(h_vec),log10.(e),label=&quot;p = $(order), slope = $(slope)&quot;)
end
@show plt</code></pre><p>The resulting plot is shown in the next figure:</p><p><img src="../../assets/poisson/convergence.png" alt/></p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] C. Johnson. <em>Numerical Solution of Partial Differential Equations by the Finite Element Method</em>. Dover Publications, 2009.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../software_install/">« Software installation</a><a class="docs-footer-nextpage" href="../T2_transient_poisson/">T2 transient poisson »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Friday 20 June 2025 15:18">Friday 20 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
