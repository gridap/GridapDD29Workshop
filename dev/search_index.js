var documenterSearchIndex = {"docs":
[{"location":"pages/E1_linear_elasticity/#Problem-statement","page":"E1 linear elasticity","title":"Problem statement","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"We want to solve a linear elasticity problem defined on the 3D domain depicted in next figure.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"We impose the following boundary conditions. All components of the displacement vector are constrained to zero on the surface Gamma_rm G, which is marked in green in the figure. On the other hand, the first component of the displacement vector is prescribed to the value deltadoteq 5mm on the surface Gamma_rm B, which is marked in blue. No body or surface forces are included in this example. Formally, the PDE to solve is","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"leftlbrace\nbeginaligned\n-cdotsigma(u) = 0  text in   Omega\nu = 0  text on  Gamma_rm G\nu_1 = delta  text on  Gamma_rm B\nn cdot sigma(u)  = 0  text on   Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"The variable u stands for the unknown displacement vector, the vector n is the unit outward normal to the Neumann boundary Gamma_rm NdoteqpartialOmegasetminusleft(Gamma_rm BcupGamma_rm Gright) and sigma(u) is the stress tensor defined as","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"sigma(u) doteq lambda rm tr(varepsilon(u))  I +2 mu   varepsilon(u)","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"where I is the 2nd order identity tensor, and lambda and mu are the Lamé parameters of the material. The operator varepsilon(u)doteqfrac12left(nabla u + (nabla u)^T right) is the symmetric gradient operator (i.e., the strain tensor). Here, we consider material parameters corresponding to aluminum with Young's modulus E=70cdot 10^9 Pa and Poisson's ratio nu=033. From these values, the Lamé parameters are obtained as lambda = (Enu)((1+nu)(1-2nu)) and mu=E(2(1+nu)).","category":"page"},{"location":"pages/E1_linear_elasticity/#Numerical-scheme","page":"E1 linear elasticity","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"We use a conventional Galerkin FE method with conforming Lagrangian FE spaces. For this formulation, the weak form is: find uin U such that $ a(u,v) = 0 $ for all vin V_0, where U is the subset of functions in VdoteqH^1(Omega)^3 that fulfill the Dirichlet boundary conditions of the problem, whereas V_0 are functions in V fulfilling v=0 on Gamma_rm G and v_1=0 on Gamma_rm B. The bilinear form of the problem is","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"a(uv)doteq int_Omega varepsilon(v)  sigma(u)  rm dOmega","category":"page"},{"location":"pages/E1_linear_elasticity/#Load-and-inspect-the-discrete-model","page":"E1 linear elasticity","title":"Load and inspect the discrete model","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"On top of it's mesh-generation functionalities, Gridap provides a convenient ways to read and write discrete models from and to files. We import the model for this problem from GMSH as follows:","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"using Gridap, GridapGmsh\nusing Gridap.Io\nusing DrWatson\n\nmsh_file_gmsh = projectdir(\"meshes/elasticity.msh\")\nmodel = GmshDiscreteModel(msh_file_gmsh)","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"This model contains the mesh and the physical tags of the model, which have been created directly through GMSH. Another option would be to create the model using Gridap, then exporting to .json format in the following way:","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"msh_file_json = projectdir(\"meshes/elasticity.json\")\nto_json_file(model,msh_file_json)","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"We can then load the saved model","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"model = DiscreteModelFromFile(msh_file_json)","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"You can easily inspect the generated discrete model in ParaView by writing it in vtk format.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"writevtk(model,datadir(\"elasticity_model\"))","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"The previous line generates four different files model_0.vtu, model_1.vtu, model_2.vtu, and model_3.vtu containing the vertices, edges, faces, and cells present in the discrete model. Moreover, you can easily inspect which boundaries are defined within the model.","category":"page"},{"location":"pages/E1_linear_elasticity/#Exercise-1","page":"E1 linear elasticity","title":"Exercise 1","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Open the resulting files with ParaView. Visualize the faces of the model and color them by each of the available fields. Identify the field names representing the boundaries \\Gamma{\\rm B}$ and Gamma_rm G._","category":"page"},{"location":"pages/E1_linear_elasticity/#Set-up-the-vector-valued-FE-space-with-Dirichlet-BCs-in-selected-components","page":"E1 linear elasticity","title":"Set up the vector-valued FE space with Dirichlet BCs in selected components","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"We will construct the vector-valued test FE space as follows:","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"order = 1\nreffe = ReferenceFE(lagrangian,VectorValue{3,Float64},order)\nV0 = TestFESpace(model,reffe;\n conformity=:H1,\n dirichlet_tags=dirichlet_tags,\n dirichlet_masks=dirichlet_masks)","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"The vector-valued interpolation is selected via the option valuetype=VectorValue{3,Float64}, where we use the type VectorValue{3,Float64}, which is the way Gridap represents vectors of three Float64 components.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"In the next two exercises, we will fill in","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"the dirichlet_tags optional argument to identify the Dirichlet regions, and\nthe dirichlet_masks optional argument to specify which components of the displacement are constrained.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Let's go step-by-step.","category":"page"},{"location":"pages/E1_linear_elasticity/#Exercise-2","page":"E1 linear elasticity","title":"Exercise 2","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Fill in the `dirichlettags` using the tag names identified in Exercise 2 for Gamma_rm B and Gamma_rm G._","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Hint: The general input format of dirichlet_tags is a one-dimensional array of tag name strings [\"tag_name_1\",...,\"tag_name_n\"].","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"# Solution for exercise 2","category":"page"},{"location":"pages/E1_linear_elasticity/#Exercise-3","page":"E1 linear elasticity","title":"Exercise 3","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Fill in the `dirichletmasks` to select the displacement components to constrain._","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Hint: The general input format of dirichlet_masks is a one-dimensional array with the same length and order as dirichlet_tags. Each entry of dirichlet_masks is a boolean tuple of length the problem dimension D, i.e. (bool_x1,...,bool_xD). If bool_xi == true, then the xi component of the displacement is constrained, otherwise it is free. Beware of passing the dirichlet_masks in the same order as the dirichlet_tags.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Recall that we constrain only the first component on the boundary Gamma_rm B, whereas we constrain all components on Gamma_rm G.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"# Solution for exercise 3","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"We can now instantiate the vector-valued test FE space.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"order = 1\nreffe = ReferenceFE(lagrangian,VectorValue{3,Float64},order)\nV0    = TestFESpace(model,reffe;\n                    conformity=:H1,\n                    dirichlet_tags=dirichlet_tags,\n                    dirichlet_masks=dirichlet_masks)","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Next, we construct the trial FE space. The Dirichlet boundary conditions must be described with two different functions, one for boundary Gamma_rm B and another one for Gamma_rm G.","category":"page"},{"location":"pages/E1_linear_elasticity/#Exercise-4","page":"E1 linear elasticity","title":"Exercise 4","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Define the Dirichlet functions according to the problem statement.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Hint: The functions must be vector-valued with the format VectorValue(val_x1,...,val_xD).","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"# Solution for exercise 4","category":"page"},{"location":"pages/E1_linear_elasticity/#Exercise-5","page":"E1 linear elasticity","title":"Exercise 5","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Define the trial FE space U.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Hint: Pass the Dirichlet functions in a one-dimensional array, in the same order as dirichlet_tags and dirichlet_masks.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"# Solution for exercise 5","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"We will now visually check the Dirichlet values are being correctly assigned on the Dirichlet boundaries.","category":"page"},{"location":"pages/E1_linear_elasticity/#Exercise-6","page":"E1 linear elasticity","title":"Exercise 6","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Create a BoundaryTriangulation of the Dirichlet boundaries.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"# Solution for exercise 6","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Next, we create a FE Function of U with zero-valued free values.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"vh = zero(U)","category":"page"},{"location":"pages/E1_linear_elasticity/#Exercise-7","page":"E1 linear elasticity","title":"Exercise 7","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Plot vh on the Dirichlet boundaries using writevtk","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"# Solution for exercise 7","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"The plot of the x-component of vh should look as follows.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Why do the results at the contour of \\Gamma{\\rm B}$ look weird?_","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"The reason is because we are enforcing the Dirichlet values only in the interior of the Dirichlet regions. So, in the contour of Gamma_rm B the x-component of the DoF values must be zero. We can use the tag names of the model ending with _c to enforce the Dirichlet conditions on the boundary closure too.","category":"page"},{"location":"pages/E1_linear_elasticity/#From-weak-form-to-visualising-the-Solution","page":"E1 linear elasticity","title":"From weak form to visualising the Solution","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/#Exercise-8","page":"E1 linear elasticity","title":"Exercise 8","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Read the details about how we define weak form, solve the problem and visualise the results.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"The construction of the weak form needs to account for the constitutive law that relates strain and stress. The symmetric gradient operator is represented by the function ε provided by Gridap (also available as symmetric_gradient). However, function σ representing the stress tensor is not predefined in the library and it has to be defined ad-hoc by the user, namely","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"const E = 70.0e9\nconst ν = 0.33\nconst λ = (E*ν)/((1+ν)*(1-2*ν))\nconst μ = E/(2*(1+ν))\nσ(ε) = λ*tr(ε)*one(ε) + 2*μ*ε","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Function σ takes a strain tensor ε (one can interpret this strain as the strain at an arbitrary integration point) and computes the associated stress tensor using the Lamé operator.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"We build now the integration mesh and the corresponding measure","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"degree = 2*order\nΩ      = Triangulation(model)\ndΩ     = Measure(Ω,degree)","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"From these objects and the constitutive law previously defined, we can write the weak form as follows","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"a(u,v) = ∫( (σ∘ε(u)) ⊙ ε(v) )dΩ\nl(v)   = 0","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Note that we have composed function σ with the strain field ε(u) in order to compute the stress field associated with the trial function u. The linear form is simply l(v) = 0 since there are not external forces in this example.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"The remaining steps for solving the FE problem are rather standard.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"op = AffineFEOperator(a,l,U,V0)\nuh = solve(op)","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Finally, we write the results to a file. Note that we also include the strain and stress tensors into the results file.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"out_file = datadir(\"elasticity_sol\")\nwritevtk(Ω,out_file,cellfields=[\"uh\"=>uh,\"epsi\"=>ε(uh),\"sigma\"=>σ∘ε(uh)])","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"If you plot the deformed displacement in ParaView, it can be clearly observed (see next figure) that the surface Gamma_rm B is pulled in x_1-direction and that the solid deforms accordingly.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/E1_linear_elasticity/#Bonus-exercise","page":"E1 linear elasticity","title":"Bonus exercise","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Modify this model to solve a multi-material linear elasticity problem as done here.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"Exercise done!","category":"page"},{"location":"pages/E1_linear_elasticity/#References","page":"E1 linear elasticity","title":"References","text":"","category":"section"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"This exercise is adapted from the Gridap Tutorial 3: Linear elasticity.","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"","category":"page"},{"location":"pages/E1_linear_elasticity/","page":"E1 linear elasticity","title":"E1 linear elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/T3_p_laplacian/#Problem-statement","page":"T3 p laplacian","title":"Problem statement","text":"","category":"section"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"The goal of this tutorial is to solve a nonlinear PDE in Gridap. For the sake of simplicity, we consider the p-Laplacian equation as the model problem. Specifically, the PDE  we want to solve is: find the scalar-field u such that","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"leftlbrace\nbeginaligned\n-nabla cdot left( nabla u^p-2  nabla u right) = f text in  Omega\nu = 0  text on   Gamma_0\nu = g  text on   Gamma_g\n n cdot left( nabla u^p-2 nabla u right)= 0  text on   Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"with p2. The computational domain Omega is the one depicted in next figure. We want to solve the Poisson equation on the 3D domain depicted in next figure with Dirichlet and Neumann boundary conditions. We impose homogeneous Dirichlet and homogeneous Neumann boundary conditions on Gamma_0 and Gamma_rm N  respectively, and inhomogeneous Dirichlet conditions on Gamma_g. The Dirichlet boundaries Gamma_0 and Gamma_g are defined as the closure of the green and blue surfaces in next figure respectively, whereas the Neumann boundary is Gamma_rm NdoteqpartialOmega setminus (Gamma_0cupGamma_g). In this example, we consider the values p=3, f=1, and g=2.","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"(Image: )","category":"page"},{"location":"pages/T3_p_laplacian/#Numerical-scheme","page":"T3 p laplacian","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"We discretize the problem with conforming Lagrangian FE spaces. For this formulation, the nonlinear weak form reads: find uin U_g such that r(u)(v) = 0 for all vin V_0. As in previous tutorials, the space U_g is the set of functions in H^1(Omega) that fulfill the Dirichlet boundary conditions, whereas V_0 is composed by functions in H^1(Omega) that vanish at the Dirichlet boundary. The weak residual r(u) evaluated at a function  uin U_g is the linear form defined as","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"r(u)(v) doteq int_Omega nabla v cdot left( nabla u^p-2 nabla u right)  rm dOmega - int_Omega v f  rm dOmega","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"In order to solve this nonlinear weak equation, we consider a Newton-Raphson method, which is associated with a linearization of the problem in an arbitrary direction delta uin V_0, namely r(u+delta u)(v)approx r(u)(v) + j(u)(delta uv). In previous formula,  j(u) is the Jacobian evaluated at uin U_g, which is the bilinear form","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"j(u)(delta uv) = int_Omega nabla v cdot left( nabla u^p-2 nabla delta u right)  rm dOmega + (p-2) int_Omega nabla v cdot left(  nabla u^p-4 (nabla u cdot nabla delta u) nabla u  right)  rm dOmega","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"Note that the solution of this nonlinear PDE with a Newton-Raphson method, will require to discretize both the residual r and the Jacobian j. In Gridap, this is done by following an approach similar to the one already shown in previous tutorials for discretizing the bilinear and linear forms associated with a linear FE problem. The specific details are discussed now.","category":"page"},{"location":"pages/T3_p_laplacian/#Discrete-model","page":"T3 p laplacian","title":"Discrete model","text":"","category":"section"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"As in previous tutorials, the first step to solve the PDE is to load a discretization of the computational domain. In this case, we load the model from the same file as in the first tutorial","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"using Gridap\nusing DrWatson\nmodel = DiscreteModelFromFile(\"meshes/poisson.json\")","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"As stated before, we want to impose Dirichlet boundary conditions on Gamma_0 and Gamma_g,  but none of these boundaries is identified in the model. E.g., you can easily see by writing the model in vtk format","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"writevtk(model,\"model\")","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"and by opening the file \"model_0\" in ParaView that the boundary identified as \"sides\" only includes the vertices in the interior of Gamma_0, but here we want to impose Dirichlet boundary conditions in the closure of Gamma_0, i.e., also on the vertices on the contour of Gamma_0. Fortunately, the objects on the contour of Gamma_0 are identified  with the tag \"sides_c\" (see next figure). Thus, the Dirichlet boundary Gamma_0 can be built as the union of the objects identified as \"sides\" and \"sides_c\".","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"(Image: )","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"Gridap provides a convenient way to create new object identifiers (referred to as \"tags\") from existing ones. First, we need to extract from the model, the object that holds the information about the boundary identifiers (referred to as FaceLabeling):","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"labels = get_face_labeling(model)","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"Then, we can add new identifiers (aka \"tags\") to it. In the next line, we create a new tag called \"diri0\" as the union of the objects identified as \"sides\" and \"sides_c\", which is precisely what we need to represent the closure of the Dirichlet boundary Gamma_0.","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"add_tag_from_tags!(labels,\"diri0\",[\"sides\", \"sides_c\"])","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"We follow the same approach to build a new identifier for the closure of the Dirichlet boundary Gamma_g. In this case, the boundary is expressed as the union of the objects identified with the tags \"circle\", \"circle_c\", \"triangle\", \"triangle_c\", \"square\", \"square_c\". Thus, we create a new tag for  Gamma_g, called \"dirig\" simply as follows:","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"add_tag_from_tags!(labels,\"dirig\",\n  [\"circle\",\"circle_c\", \"triangle\", \"triangle_c\", \"square\", \"square_c\"])","category":"page"},{"location":"pages/T3_p_laplacian/#FE-Space","page":"T3 p laplacian","title":"FE Space","text":"","category":"section"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"Now, we can build the FE space by using the newly defined boundary tags.","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"reffe = ReferenceFE(lagrangian,Float64,1)\nV0 = TestFESpace(model,reffe,conformity=:H1,labels=labels,dirichlet_tags=[\"diri0\", \"dirig\"])","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"The construction of this space is essentially the same as in the first tutorial (we build a continuous scalar-valued Lagrangian interpolation of first order). However, we also pass here the labels object (that contains the newly created boundary tags). From this FE space, we define the trial FE spaces","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"g = 1\nUg = TrialFESpace(V0,[0,g])","category":"page"},{"location":"pages/T3_p_laplacian/#Nonlinear-FE-problem","page":"T3 p laplacian","title":"Nonlinear FE problem","text":"","category":"section"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"At this point, we are ready to build the nonlinear FE problem. To this end, we need to define the weak residual and also its corresponding Jacobian. This is done following a similar procedure to the one considered in previous tutorials to define the bilinear and linear forms associated with linear FE problems. We first need to define the usual objects for numerical integration:","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"degree=2\nΩ = Triangulation(model)\ndΩ = Measure(Ω,degree)","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"On the one hand, the weak residual is built as follows","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"const p = 3\nflux(∇u) = norm(∇u)^(p-2) * ∇u\nf(x) = 1\nres(u,v) = ∫( ∇(v)⊙(flux∘∇(u)) - v*f )*dΩ","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"Function res is the one representing the integrand of the weak residual r(u)(v). The first argument of function res stands for the function uin U_g, where the residual is evaluated, and the second argument stands for a generic test function vin V_0.","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"On the other hand,  we (optionally) implement a function jac representing the Jacobian.","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"dflux(∇du,∇u) = (p-2)*norm(∇u)^(p-4)*(∇u⊙∇du)*∇u+norm(∇u)^(p-2)*∇du\njac(u,du,v) = ∫( ∇(v)⊙(dflux∘(∇(du),∇(u))) )*dΩ","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"The first argument of function jac stands for function uin U_g, where the Jacobian is evaluated. The second argument is a test function vin V_0, and the third argument represents an arbitrary direction delta u in V_0.","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"We finally construct the nonlinear FE problem","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"op = FEOperator(res,jac,Ug,V0)","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"Here, we have constructed an instance of FEOperator, which is the type that represents a general nonlinear FE problem in Gridap. The constructor takes the functions representing the weak residual and Jacobian, and the test and trial spaces. If only the function for the residual is provided, the Jacobian is computed internally with automatic differentiation:","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"op_AD = FEOperator(res,Ug,V0)","category":"page"},{"location":"pages/T3_p_laplacian/#Nonlinear-solver-phase","page":"T3 p laplacian","title":"Nonlinear solver phase","text":"","category":"section"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"We have already built the nonlinear FE problem. Now, the remaining step is to solve it. In Gridap, nonlinear (and also linear) FE problems can be solved with instances of the type FESolver.","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"We construct an instance of FESolver as follows:","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"using LineSearches: BackTracking\nnls = NLSolver(\n  show_trace=true, method=:newton, linesearch=BackTracking())\nsolver = FESolver(nls)","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"Note that the NLSolver function used above internally calls the nlsolve function of the NLsolve package with the provided key-word arguments. Thus, one can use any of the nonlinear methods available via the function nlsolve to solve the nonlinear FE problem. Here, we have selected a Newton-Raphson method with a back-tracking line-search from the LineSearches package.","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"We are finally in place to solve the nonlinear FE problem. The initial guess is a FEFunction, which we build from a vector of random (free) nodal values:","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"import Random\nRandom.seed!(1234)\nx = rand(Float64,num_free_dofs(Ug))\nuh0 = FEFunction(Ug,x)\nuh, = solve!(uh0,solver,op)","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"We finish this tutorial by writing the computed solution for visualization (see next figure).","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"writevtk(Ω,datadir(\"p_laplacian\"),cellfields=[\"uh\"=>uh])","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"(Image: )","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"","category":"page"},{"location":"pages/T3_p_laplacian/","page":"T3 p laplacian","title":"T3 p laplacian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"software_install/#Software-installation","page":"Software installation","title":"Software installation","text":"","category":"section"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"The practical part of the workshop will consist of instructors' guided hands-on tutorials and exercises. You will find below the instructions to set up the software environment required to run the tutorials.","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"NOTE: In the case you have any issues while following these instructions, please fill an issue here and we will try to help you out. This will also help other participants that may have the same issue.","category":"page"},{"location":"software_install/#Required-software","page":"Software installation","title":"Required software","text":"","category":"section"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"Before being able to work on the workshop material, you will need to install the following software on your laptop:","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"Install git, the version control system we will use. For Windows users, we strongly recommend installing git for Windows. This will also install a bash shell, which will allow you to follow the rest of the installation instructions verbatim.\nDownload and install Julia based on the platform you are using from the Julia home page.\nDownload and install VSCode based on the platform you are using from the VSCode home page. \nInstall and configure the Julia extension for VSCode. Some interesting features of the Julia extension for VSCode are covered in the following YouTube video.\nInstall ParaView post-processing software. We will use the basic features of ParaView. In any case, if you are  keen on learning more,  there is a whole YouTube channel on ParaView that will give you many more ideas.","category":"page"},{"location":"software_install/#Getting-the-workshop-material","page":"Software installation","title":"Getting the workshop material","text":"","category":"section"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"The workshop material is available as a git repository here. You can either download it as a zip file or clone the repository using git. We strongly recommend the latter as you will be able to automatically pull the most up-to-date changes as per required.","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"If your system has an ssh client, you can clone the repository using the following command","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"git clone git@github.com:gridap/GridapDD29Workshop.git","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"from the terminal. In order this command to be successful, you will need to generate a pair of public/private SSH keys, and then associate the public key to your GitHub account. You may find some instructions on how to do this here. If, for whatever reason, you are not able to succeed, you may also try:","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"git clone https://github.com/gridap/GridapDD29Workshop.git","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"which does not require the aforementioned pair of public/private SSH keys.","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"Alternative methods to clone the repository can be found here.","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"Once you have cloned the repository, you can pull the most up-to-date changes with the following command executed from the root directory of the repository:","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"git pull origin","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"You may expect changes in the tutorials and exercises till the very last minute. These instructions are mostly definitive, though.","category":"page"},{"location":"software_install/#Setting-up-the-environment-on-your-local-computer-from-the-terminal","page":"Software installation","title":"Setting up the environment on your local computer from the terminal","text":"","category":"section"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"Move into the newly cloned repository and start Julia from the terminal by typing","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"julia --project=.","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"Then, press ] to enter the package manager and run","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"(GridapDD29Workshop) pkg> instantiate\n(GridapDD29Workshop) pkg> update\n(GridapDD29Workshop) pkg> build","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"to install and precompile all the packages needed for the workshop. This may take a while.","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"To render Jypyter notebooks interactively, you also need to run the following:","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"  julia -e'using Pkg; Pkg.add(\"IJulia\")'","category":"page"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"More information on Julia Environments can be found here.","category":"page"},{"location":"software_install/#Setting-up-the-environment-on-your-local-computer-with-VSCode","page":"Software installation","title":"Setting up the environment on your local computer with VSCode","text":"","category":"section"},{"location":"software_install/","page":"Software installation","title":"Software installation","text":"Open VSCode. Then, on the top menu, select File->Open Folder, and select the workshop's material folder you just cloned.\nEnsure that the Julia environment in the bottom status bar of VSCode is GridapDD29Workshop. Click here for instructions on how to do that.\nOpen the Julia REPL in VSCode. To this end, open the command palette with the keyboard key combination Crtl+Shift+P.\nOn the command palette, type \"julia\". You should get a drop-down list with different options. Select Julia: Start REPL option. This should open the Julia REPL on the VSCode's terminal window at the bottom.\nRun the instantiate package manager command as described in the previous section.","category":"page"},{"location":"pages/T1_poisson/#Problem-statement","page":"T1 poisson","title":"Problem statement","text":"","category":"section"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"In this first tutorial, we provide an overview of a complete simulation pipeline in Gridap: from the construction of the FE mesh to the visualization of the computed results. To this end, we consider a simple model problem: the Poisson equation.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"We want to solve the Poisson equation on the 3D cartesian domain -pipitimes-pi2pi2times01 with Dirichlet and Neumann boundary conditions. Neumann boundary conditions are applied on Gamma_rm N =  z = 0  cup  z = 1 , i.e the bottom and top boundaries. Dirichlet boundary conditions are applied everywhere else, i.e Gamma_rm D =  x = -pi  cup  x = pi  cup  y = -pi2  cup  y = pi2 .","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Formally, the problem to solve is: find the scalar field u such that","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"leftlbrace\nbeginaligned\n-Delta u = f   text in   Omega\nu = g  text on  Gamma_rm D\n n cdot nabla u = h  text on   Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"with n being  the outwards unit normal vector to the Neumann boundary Gamma_rm N. In this tutorial, we will try to recover an analytical solution u_0(xyz) = rm cos(x) rm sin(y+π) and analyze the convergence rates of our numerical approximation.","category":"page"},{"location":"pages/T1_poisson/#Numerical-scheme","page":"T1 poisson","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"To solve this PDE, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1] for specific details on this formulation). The weak form associated with this formulation is: find uin U such that $ a(u,v) = l(v) $ for all vin V, where U and V are the subset of functions in H^1(Omega) that fulfill the Dirichlet boundary condition g and 0 respectively. The bilinear and linear forms for this problems are","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"  a(uv) doteq int_Omega nabla v cdot nabla u  rm dOmega quad l(v) doteq int_Omega v f   rm  dOmega + int_Gamma_rm N v h  rm dGamma_rm N","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"The problem is solved numerically by approximating the spaces U and V by their discrete counterparts associated with a FE mesh of the computational domain Omega. As we have anticipated, we consider standard conforming Lagrangian FE spaces for this purpose.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"The implementation of this numerical scheme in Gridap is done in a user-friendly way thanks to the abstractions provided by the library. As it will be seen below, all the mathematical objects involved in the definition of the discrete weak problem have a correspondent representation in the code.","category":"page"},{"location":"pages/T1_poisson/#Setup","page":"T1 poisson","title":"Setup","text":"","category":"section"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"The step number 0 in order to solve the problem is to load the Gridap library in the code. For convenience, we will also be using DrWatson.jl. If you have configured your Julia environment properly, it is simply done with the line:","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"using Gridap\nusing DrWatson","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"We define the analytical solution we will try to retrieve as follows:","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"u₀(x)  = cos(x[1])*sin(x[2]+π)\n∇u₀(x) = VectorValue(-sin(x[1])*sin(x[2]+π),cos(x[1])*cos(x[2]+π),0.0)\nΔu₀(x) = -2.0*cos(x[1])*sin(x[2]+π)","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"We also define the other functions involved in the problem statement:","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"f(x) = -Δu₀(x)\ng(x) = u₀(x)\nh(x) = 0.0      # ∇u₀ ⋅ n_Γ = ∇u₀ ⋅ ± e₃ = 0","category":"page"},{"location":"pages/T1_poisson/#Discrete-model","page":"T1 poisson","title":"Discrete model","text":"","category":"section"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"As in any FE simulation, we need a discretization of the computational domain (i.e., a FE mesh). All geometrical data needed for solving a FE problem is provided in Gridap by types inheriting from the abstract type DiscreteModel. In our particular case, we will create a CartesianDiscreteModel of the computational domain Omega = -pipitimes-pi2pi2times01 with a resolution n_C=(n_xn_yn_z)","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"domain = (-π,π,-π/2,π/2,0,1)\nnC     = (100,40,5)\nmodel  = CartesianDiscreteModel(domain,nC)","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"By construction, a CartesianDiscreteModel associates with labels every vertex, edge and facet of the model to its parent corner, edge, facet or interior of the grid's bounding box. Label numbering follows the increasing lexicographic order.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"We use this default order to set up the BCs as follows. For convenience, we create two new boundary tags, namely \"dirichlet\" and \"neumann\".","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Gridap provides a convenient way to create new object identifiers (referred to as \"tags\") from existing ones. First, we need to extract from the model, the object that holds the information about the boundary identifiers (referred to as FaceLabeling):","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"labels = get_face_labeling(model)","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Then, we can add new identifiers (aka \"tags\") to it. In the next line, we create new tags called \"dirichlet\" and \"neumann\" combining the default labels of the model to represent Gamma_D and Gamma_N respectively.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"add_tag_from_tags!(labels,\"neumann\",[\"tag_21\",\"tag_22\"])\nadd_tag_from_tags!(labels,\"dirichlet\",[\"tag_23\",\"tag_24\",\"tag_25\",\"tag_26\"])","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Note the usage of add_tag_from_tags! to construct new boundary tags gathering lower-level tags.","category":"page"},{"location":"pages/T1_poisson/#Approximation-spaces","page":"T1 poisson","title":"Approximation spaces","text":"","category":"section"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"order = 1\nreffe = ReferenceFE(lagrangian,Float64,order)\nV = TestFESpace(model,reffe;conformity=:H1,dirichlet_tags=\"dirichlet\")","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Here, we have used the TestFESpace constructor, which constructs a particular FE space (to be used as a test space) from a set of options described as positional and key-word arguments. The first positional argument is the model on top of which we want to build the space. The second positional argument contains information about the type of FE interpolation (the reference FE in this case). With ReferenceFE(lagrangian,Float64,order) We select a scalar-valued Lagrangian reference FE of order 1, where the value of the shape functions will be represented with  64-bit floating point numbers. With the key-word argument conformity we define the regularity of the interpolation at the boundaries of the cells in the mesh. Here, we use conformity=:H1, which means that the resulting interpolation space is a subset of H^1(Omega) (i.e., continuous shape functions). On the other hand, we pass the identifiers of the Dirichlet boundary via the dirichlet_tags argument. Since this is a test space, the corresponding shape functions vanishes at the Dirichlet boundary.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Once the space V is discretized in the code, we proceed with the approximation of the trial space U.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"U = TrialFESpace(V,g)","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"To this end, we have used the TrialFESpace constructors. Note that we have passed a function representing the value of the Dirichlet boundary condition, when building the trial space (here our analytical solution).","category":"page"},{"location":"pages/T1_poisson/#Numerical-integration","page":"T1 poisson","title":"Numerical integration","text":"","category":"section"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Once we have built the interpolation spaces, the next step is to set up the machinery to perform the integrals in the weak form numerically. Here, we need to compute integrals on the interior of the domain Omega and on the Neumann boundary Gamma_rm N. In both cases, we need two main ingredients. We need to define an integration mesh (i.e. a triangulation of the integration domain), plus a Gauss-like quadrature in each of the cells in the triangulation. In Gridap, integration meshes are represented by types inheriting from the abstract type Triangulation. For integrating on the domain Omega, we build the following triangulation and the corresponding Lebesgue measure, which will allow to write down integrals in a syntax similar to the usual mathematical notation.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"degree = order*2\nΩ  = Triangulation(model)\ndΩ = Measure(Ω,degree)","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Here, we build a triangulation from the cells of the model and build (an approximation of) the Lebesgue measure using a quadrature rule of degree 2 in the cells of this triangulation. This is enough for integrating the corresponding terms of the weak form exactly for an interpolation of order 1.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"On the other hand, we need a special type of triangulation, represented by the type BoundaryTriangulation, to integrate on the boundary. Essentially, a BoundaryTriangulation is a particular type of Triangulation that is aware of which cells in the model are touched by faces on the boundary. We build an instance of this type from the discrete model and the names used to identify the Neumann boundary as follows:","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Γ   = BoundaryTriangulation(model,tags=\"neumann\")\ndΓ  = Measure(Γ,degree)","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"In addition, we have created a quadrature of degree 2 on top of the cells in the triangulation for the Neumann boundary.","category":"page"},{"location":"pages/T1_poisson/#Weak-form","page":"T1 poisson","title":"Weak form","text":"","category":"section"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"With all the ingredients presented so far, we are ready to define the weak form. This is done by defining functions representing the bi-linear and linear forms:","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"a(u,v) = ∫( ∇(v)⋅∇(u) )*dΩ\nl(v)   = ∫( v*f )*dΩ + ∫( v*h )*dΓ","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Note that by using the integral function ∫, the Lebesgue measures dΩ, dΓ, and the gradient function ∇, the weak form is written with an obvious relation with the corresponding mathematical notation.","category":"page"},{"location":"pages/T1_poisson/#FE-Problem","page":"T1 poisson","title":"FE Problem","text":"","category":"section"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"At this point, we can build the FE problem that, once solved, will provide the numerical solution we are looking for. A FE problem is represented in Gridap by types inheriting from the abstract type FEOperator (both for linear and nonlinear cases). Since we want to solve a linear problem, we use the concrete type AffineFEOperator, i.e., a problem represented by a matrix and a right hand side vector.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"op = AffineFEOperator(a,l,U,V)","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Note that the AffineFEOperator object representing our FE problem is built from the function a and l representing the weak form and test and trial FE spaces V and U.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"We can also retrieve the matrix and the right hand side vector of the problem as follows:","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"A = get_matrix(op)\nb = get_vector(op)","category":"page"},{"location":"pages/T1_poisson/#Solver-phase","page":"T1 poisson","title":"Solver phase","text":"","category":"section"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"We have constructed a FE problem, the last step is to solve it. In Gridap, FE problems are solved with types inheriting from the abstract type FESolver. Since this is a linear problem, we use a LinearFESolver:","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"ls = LUSolver()\nsolver = LinearFESolver(ls)","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"LinearFESolver objects are built from a given algebraic linear solver. In this case, we use a LU factorization. Now we are ready to solve the FE problem with the FE solver as follows:","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"uh = solve(solver,op)","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"The solve function returns the computed numerical solution uh. This object is an instance of FEFunction, the type used to represent a function in a FE space. FEFunction is part of the CellField abstract type, which are objects that represent fields over a triangulated domain. We can inspect the result by writing it into a vtk file:","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"writevtk(Ω,datadir(\"poisson\"),cellfields=[\"uh\"=>uh])","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"which will generate a file named poisson_sol.vtu having a nodal field named \"uh\" containing the solution of our problem (see next figure).","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"(Image: )","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Additionally, we can compute the L2 error of the numerical solution as follows:","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"dΩe  = Measure(Ω,degree*2)\ne = uh - u₀\nl2_error = sqrt(sum(∫(e⋅e)*dΩe))","category":"page"},{"location":"pages/T1_poisson/#Convergence-analysis","page":"T1 poisson","title":"Convergence analysis","text":"","category":"section"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"One of the advantages of having an analytical solution is that we can compute the convergence rates of our numerical approximation. The first step is to define a driver by putting together all the steps described above. The driver takes two arguments: the number of cells in the x and y direction, n, and the order of the finite-element interpolation, p. It returns the L2 error of the numerical solution.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"function driver(n,order)\n  domain = (-π,π,-π/2,π/2,0,1)\n  nC     = (n,n,1)\n  model  = CartesianDiscreteModel(domain,nC)\n  labels = get_face_labeling(model)\n  add_tag_from_tags!(labels,\"dirichlet\",[\"tag_21\",\"tag_22\"])\n  add_tag_from_tags!(labels,\"neumann\",[\"tag_23\",\"tag_24\",\"tag_25\",\"tag_26\"])\n\n  reffe = ReferenceFE(lagrangian,Float64,order)\n  V = TestFESpace(model,reffe;conformity=:H1,dirichlet_tags=\"dirichlet\")\n\n  U = TrialFESpace(V,g)\n  degree = order*2+1\n  Ω   = Triangulation(model)\n  dΩ  = Measure(Ω,degree)\n  Γ   = BoundaryTriangulation(model,tags=\"neumann\")\n  dΓ  = Measure(Γ,degree)\n\n  a(u,v) = ∫( ∇(v)⋅∇(u) )*dΩ\n  l(v)   = ∫( v*f )*dΩ + ∫( v*h )*dΓ\n  op     = AffineFEOperator(a,l,U,V)\n  ls     = LUSolver()\n  solver = LinearFESolver(ls)\n  uh = solve(solver,op)\n\n  dΩe  = Measure(Ω,degree*2)\n  e = uh - u₀\n  return sqrt(sum(∫(e⋅e)*dΩe))\nend","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"We then run the driver for different values of n and p, saving the values of the L2 error for each configuration.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"order_vec = [1,2]\nn_vec = [10,20,40,80]\nh_vec = map(n -> 1/n, n_vec)\n\nerror = zeros((length(order_vec),length(n_vec)))\nfor (i,order) in enumerate(order_vec)\n  for (j,n) in enumerate(n_vec)\n    error[i,j] = driver(n,order)\n  end\nend","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"Finally, we plot the results and compute the convergence rates.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"using Plots\nplt = plot(xlabel=\"log10(h)\",ylabel=\"log10(L2 error)\",grid=true)\nfor (i,e) in enumerate(eachrow(error))\n  order = order_vec[i]\n  dx = log10(h_vec[1]) - log10(h_vec[end])\n  dy = log10(e[1]) - log10(e[end])\n  slope = string(dy/dx)[1:4]\n  plot!(plt,log10.(h_vec),log10.(e),label=\"p = $(order), slope = $(slope)\")\nend\n@show plt","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"The resulting plot is shown in the next figure:","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"(Image: )","category":"page"},{"location":"pages/T1_poisson/#References","page":"T1 poisson","title":"References","text":"","category":"section"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"[1] C. Johnson. Numerical Solution of Partial Differential Equations by the Finite Element Method. Dover Publications, 2009.","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"","category":"page"},{"location":"pages/T1_poisson/","page":"T1 poisson","title":"T1 poisson","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/T2_transient_poisson/#Introduction","page":"T2 transient poisson","title":"Introduction","text":"","category":"section"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"In this tutorial we will learn how to use Gridap for approximating transient PDEs by using time marching schemes (method of lines). We consider the heat equation, a.k.a. the transient Poisson equation.","category":"page"},{"location":"pages/T2_transient_poisson/#Problem-statement","page":"T2 transient poisson","title":"Problem statement","text":"","category":"section"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"We solve the heat equation in a 2-dimensional domain Omega, the unit square, with Homogeneous Dirichlet boundaries on the whole boundary partial Omega. We consider a time-dependent conductivity kappa(t)=10 + 095sin(2pi t), a time-dependent volumetric forcing term f(t) = sin(pi t) and a constant Homogeneous boundary condition g = 00. The initial solution is u(x0) = u_0 = 0. With these definitions, the strong form of the problem reads:","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"leftlbrace\nbeginaligned\nfracpartial u(t)partial t -kappa(t)Delta u(t) = f(t)   text in   Omega\nu(t) = 0  text on  Gamma_rm D\nu(0) = 0  text in  Omega\nendaligned\nright","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"The weak form of the problem reads: find u(t)in U_g(t) such that","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"m(tuv) + a(tuv) = b(tv)quad forall vin  V","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"Note that U_t(t) is a transient FE space, in the sense that Dirichlet boundary value of functions in U_t can change in time (even though this is not the case in this tutorial). The definition of m(uv), a(uv) and b(v) is as follows:","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"beginaligned\nm(tuv) = int_Omega vfracpartial upartial t dOmega \na(tuv) = int_Omega kappa(t) nabla vcdot nabla u dOmega \nb(tv) = int_Omega v f(t) dOmega\nendaligned","category":"page"},{"location":"pages/T2_transient_poisson/#Discrete-model-and-Triangulation","page":"T2 transient poisson","title":"Discrete model and Triangulation","text":"","category":"section"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"As for Poisson, we start by loading the libaries and defining our DiscreteModel the Triangulation.","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"using Gridap\nusing DrWatson\n\nmodel = CartesianDiscreteModel((0,1,0,1),(20,20))\nΩ  = Triangulation(model)\ndΩ = Measure(Ω,2)","category":"page"},{"location":"pages/T2_transient_poisson/#FE-spaces","page":"T2 transient poisson","title":"FE spaces","text":"","category":"section"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"The space of test functions is constant in time and is defined like for the steady problem:","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"reffe = ReferenceFE(lagrangian,Float64,1)\nV = TestFESpace(model,reffe,dirichlet_tags=\"boundary\")","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"The trial space is now a TransientTrialFESpace, which is constructed from a TestFESpace and a function (or vector of functions) for the Dirichlet boundary condition/s. In that case, the boundary condition function is a time-independent constant, but it could also be a time-dependent field depending on the coordinates x and time t.","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"g(x,t::Real) = 0.0\ng(t::Real) = x -> g(x,t)\nU = TransientTrialFESpace(V,g)","category":"page"},{"location":"pages/T2_transient_poisson/#Weak-form","page":"T2 transient poisson","title":"Weak form","text":"","category":"section"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"The weak form of the problem follows the same structure as other Gridap tutorials, where we define the bilinear and linear forms to define the FEOperator. In this case we need to deal with time-dependent quantities and with the presence of time derivatives. The former is handled by passing the time, t, as an additional argument to the form, i.e. a(tuv). The latter is defined using the time derivative operator ∂t.","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"The most general way of constructing a transient FE operator is by using the TransientFEOperator function, which receives a residual, a jacobian with respect to the unknown and a jacobian with respect to the time derivative.","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"κ(t) = 1.0 + 0.95*sin(2π*t)\nf(t) = sin(π*t)\nres(t,u,v) = ∫( ∂t(u)*v + κ(t)*(∇(u)⋅∇(v)) - f(t)*v )dΩ\njac(t,u,du,v) = ∫( κ(t)*(∇(du)⋅∇(v)) )dΩ\njac_t(t,u,duₜ,v) = ∫( duₜ*v )dΩ\nop_NL = TransientFEOperator(res,jac,jac_t,U,V)","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"We can also take advantage of automatic differentiation techniques to compute both Jacobians and use the TransientFEOperator function sending just the residual.","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"op_AD = TransientFEOperator(res,U,V)","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"Alternatively, we can exploit the fact that the problem is linear and use the transient Linear FE operator signature TransientLinearFEOperator. In that case, we send a form for the mass contribution, m, a form for the stiffness contribution, a, and the forcing term, b.","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"m(t,u,v) = ∫( u*v )dΩ\na(t,u,v) = ∫( κ(t)*(∇(u)⋅∇(v)) )dΩ\nb(t,v) = ∫( f(t)*v )dΩ\nop_Af = TransientLinearFEOperator((a,m),b,U,V)","category":"page"},{"location":"pages/T2_transient_poisson/#Alternative-FE-operator-definitions","page":"T2 transient poisson","title":"Alternative FE operator definitions","text":"","category":"section"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"For time-dependent problems with constant coefficients, which is not the case of this tutorial, one could use the kwarg constant_forms = (true, true) to indicate that the matrix contributions (m and a) are time-independent. That is:","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"m₀(u,v) = ∫( u*v )dΩ\na₀(u,v) = ∫( κ(0.0)*(∇(u)⋅∇(v)) )dΩ\nop_CM =  TransientLinearFEOperator((a, m), b, U, V, constant_forms=(true, true))","category":"page"},{"location":"pages/T2_transient_poisson/#Transient-solver","page":"T2 transient poisson","title":"Transient solver","text":"","category":"section"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"Once we have the FE operator defined, we proceed with the definition of the transient solver. First, we define a linear solver to be used at each time step. Here we use the LUSolver, but other choices are possible.","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"linear_solver = LUSolver()","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"Then, we define the ODE solver. That is, the scheme that will be used for the time integration. In this tutorial we use the ThetaMethod with theta = 05, resulting in a 2nd order scheme. The ThetaMethod function receives the linear solver, the time step size Delta t (constant) and the value of theta.","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"Δt = 0.05\nθ = 0.5\node_solver = ThetaMethod(linear_solver,Δt,θ)","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"Finally, we define the solution using the solve function, giving the ODE solver, the FE operator, an initial solution, an initial time and a final time. To construct the initial condition we interpolate the initial value (in that case a constant value of 0.0) into the FE space U(t) at t=00.","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"t₀ = 0.0\nT = 10.0\nu₀ = interpolate_everywhere(0.0,U(0.0))\nuₕₜ = solve(ode_solver,op_CM,t₀,T,u₀)","category":"page"},{"location":"pages/T2_transient_poisson/#Postprocessing","page":"T2 transient poisson","title":"Postprocessing","text":"","category":"section"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"We should highlight that uₕₜ is just an iterable function and the results at each time steps are only computed when iterating over it, i.e., lazily. We can post-process the results and generate the corresponding vtk files using the createpvd and createvtk functions. The former will create a .pvd file with the collection of .vtu files saved at each time step by createvtk. The computation of the problem solutions will be triggered in the following loop:","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"dir = datadir(\"poisson_transient_solution\")\n!isdir(dir) && mkdir(dir)\ncreatepvd(dir) do pvd\n  for (t,uₕ) in uₕₜ\n    file = dir*\"/solution_$t\"*\".vtu\"\n    pvd[t] = createvtk(Ω,file,cellfields=[\"u\"=>uₕ])\n  end\nend","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"(Image: )","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"","category":"page"},{"location":"pages/T2_transient_poisson/","page":"T2 transient poisson","title":"T2 transient poisson","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/T4_stokes/#Problem-statement","page":"T4 stokes","title":"Problem statement","text":"","category":"section"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"The goal is to solve a linear multi-field PDE with saddle point structure. As a model problem, we consider a well known benchmark in computational fluid dynamics, the lid-driven cavity benchmark for the incompressible Stokes equations at low Reynolds numbers. We will be using a mixed finite-element with a well know inf-sup stable element pair Q_kP_k-1^- for velocity/pressure.","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"Formally, the PDE we want to solve is: find the velocity vector u and the pressure p such that","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"leftlbrace\nbeginaligned\n- mathitRe Delta u + nabla p = 0 text in Omega\nnablacdot u = 0 text in  Omega\nu = g text on  partialOmega\nendaligned\nright","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"where the computational domain is the unit square Omega doteq (01)^d, d=2, and mathitRe is the Reynolds number. In this example, the driving force is the Dirichlet boundary velocity g, which is a non-zero horizontal velocity with a value of g = (10)^t on the top side of the cavity, namely the boundary (01)times1, and g=0 elsewhere on partialOmega. Since we impose Dirichlet boundary conditions on the entire boundary partialOmega, the mean value of the pressure is constrained to zero in order have a well posed problem,","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"using Gridap\nusing DrWatson","category":"page"},{"location":"pages/T4_stokes/#Geometry","page":"T4 stokes","title":"Geometry","text":"","category":"section"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"Discrete model","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"n = 100\ndomain = (0,1,0,1)\npartition = (n,n)\nmodel = CartesianDiscreteModel(domain, partition)","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"Define Dirichlet boundaries","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"labels = get_face_labeling(model)\nadd_tag_from_tags!(labels,\"diri1\",[6,])\nadd_tag_from_tags!(labels,\"diri0\",[1,2,3,4,5,7,8])","category":"page"},{"location":"pages/T4_stokes/#FE-spaces","page":"T4 stokes","title":"FE spaces","text":"","category":"section"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"We define reference finite-element pair Q_kP_k-1^-","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"order = 2\nreffeᵤ = ReferenceFE(lagrangian,VectorValue{2,Float64},order)\nreffeₚ = ReferenceFE(lagrangian,Float64,order-1;space=:P)","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"We then define the test spaces for velocity and pressure: Note that the pressure space is defined as a L2-conforming space with zero mean constraint.","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"V = TestFESpace(model,reffeᵤ,labels=labels,dirichlet_tags=[\"diri0\",\"diri1\"],conformity=:H1)\nQ = TestFESpace(model,reffeₚ,conformity=:L2,constraint=:zeromean)","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"The trial spaces are then defined in the usual way:","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"u0 = VectorValue(0,0)\nu1 = VectorValue(1,0)\nU = TrialFESpace(V,[u0,u1])\nP = TrialFESpace(Q)","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"With all these ingredients we create the FE spaces representing the Cartesian product of the velocity and pressure FE spaces, (XY) = (U times P V times Q), which is where we are seeking the solution the problem.","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"Y = MultiFieldFESpace([V,Q])\nX = MultiFieldFESpace([U,P])","category":"page"},{"location":"pages/T4_stokes/#Integration","page":"T4 stokes","title":"Integration","text":"","category":"section"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"From the discrete model we can define the triangulation and integration measure","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"degree = order\nΩₕ = Triangulation(model)\ndΩ = Measure(Ωₕ,degree)","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"As usual, we define bilinear and linear forms for our problem. Note that, since we are using a Cartesian product FE space, it's elements are tuples. Here we use (u,p) and (v,q) to denote the trial and test functions.","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"f = VectorValue(0.0,0.0)\na((u,p),(v,q)) = ∫( ∇(v)⊙∇(u) - (∇⋅v)*p + q*(∇⋅u) )dΩ\nl((v,q)) = ∫( v⋅f )dΩ","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"We can then build the AffineFEOperator as usual and solve using our solver of choice. Note that the solver now retuns a solution, xh, which behaves like a tuple of solutions, one for each field in the space. We can then easily unpack the solution into the velocity and pressure components.","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"op = AffineFEOperator(a,l,X,Y)\nxh = solve(op)\nuh, ph = xh","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"Finally, we export the results to vtk","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"writevtk(Ωₕ,datadir(\"stokes\"),order=2,cellfields=[\"uh\"=>uh,\"ph\"=>ph])","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"","category":"page"},{"location":"pages/T4_stokes/","page":"T4 stokes","title":"T4 stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/E3_transient_navier_stokes/#Problem-statement","page":"E3 transient navier stokes","title":"Problem statement","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"The goal is to solve a time-dependent nonlinear multi-field PDE. As a model problem, we consider a well known benchmark in computational fluid dynamics, the laminar flow around a cylinder for the transient incompressible Navier-Stokes equations. We will solve this problem by building on the previous exercise.","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"Like in the previous exercise, the computational domain Omega is a 2-dimensional channel. The fluid enters the channel from the left boundary (inlet) and exits through the right boundary (outlet). The channel has a cylindrical obstacle near the inlet. The domain can be seen in the following figure:","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"(Image: )","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"We define partial Omega = Gamma_w cup Gamma_c cup Gamma_in cup Gamma_out with Gamma_w the top and bottom channel walls, Gamma_c the cylinder walls, Gamma_in the inlet and Gamma_out the outlet.","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"Formally, the PDE we want to solve is: find the velocity vector u and the pressure p such that","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"leftlbrace\nbeginaligned\nfracpartial upartial t - Delta u + mathitRe (ucdot nabla) u + nabla p = 0 text in Omega\nnablacdot u = 0 text in  Omega\nu = u_in text on  Gamma_in\nu = 0 text on  Gamma_w cup Gamma_c\nn_Gamma cdot sigma = 0 text on  Gamma_out\nendaligned\nright","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"where d=2 , and mathitRe is the Reynolds number.","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"The inflow condition is now time-dependent and given by","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"u_in(0yt) = left( 4 U_m fracy(H-y)H^2 xi(t) 0 right)","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"with U_m=15  ms the maximum velocity, H = 041  m the height of the channel and xi a function","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"xi(t) = leftlbrace\nbeginaligned\n  sinleft(fracpi t2 T_thright) text if  t leq T_th \n  10 text if  t  T_th \nendaligned\nright","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"with T_th the time it takes for the flow to reach a steady state.","category":"page"},{"location":"pages/E3_transient_navier_stokes/#Numerical-Scheme","page":"E3 transient navier stokes","title":"Numerical Scheme","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"In order to approximate this problem we choose the same formulation as before, namely a formulation based on inf-sup stable P_kP_k-1 triangular elements with continuous velocities and pressures. The interpolation spaces are defined as follows. The velocity interpolation space is","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"V doteq  v in H^1(Omega)^d v_Tin P_k(T)^d text for all  TinmathcalT ","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"where T denotes an arbitrary cell of the FE mesh mathcalT, and P_k(T) is the usual Lagrangian FE space of order k defined on a mesh of triangles or tetrahedra. On the other hand, the space for the pressure is given by","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"Q doteq  q in C^0(Omega) q_Tin P_k-1(T) text for all  TinmathcalT","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"The weak form associated to these interpolation spaces reads: find (up)in U_g times Q such that r(up)(vq)=0 for all (vq)in V_0 times Q where U_g and V_0 are the set of functions in V fulfilling the Dirichlet boundary conditions and the homogeneous Dirichlet boundary conditions respectively. The weak residual r evaluated at a given pair (up) is the linear form defined as","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"r(t(up))(vq) doteq m(t(up)(vq)) + a(t(up)(vq)) + c(u)(v)","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"with","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"beginaligned\nm(t(up)(vq)) doteq int_Omega fracpartial upartial t cdot v  rm dOmega\na(t(up)(vq)) doteq int_Omega nabla v cdot nabla u  rm dOmega - int_Omega (nablacdot v)  p  rm dOmega + int_Omega q  (nabla cdot u)  rm dOmega\nc(u)(v) doteq int_Omega v \tcdot left( (ucdotnabla) u right) rm dOmega\nendaligned","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"In this exercise, we will rely on automatic differentiation to compute the necessary jacobians in time and space.","category":"page"},{"location":"pages/E3_transient_navier_stokes/#Geometry","page":"E3 transient navier stokes","title":"Geometry","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/#Exercise-1","page":"E3 transient navier stokes","title":"Exercise 1","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"By using the code in the previous exercise, load the mesh from the file `perforatedplatetiny.msh. If your computer is good enough, or if you have access to a cluster, you might want to try the refined model in fileperforatedplate.msh`._","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"using Gridap, GridapGmsh\nusing DrWatson\n\n# model =","category":"page"},{"location":"pages/E3_transient_navier_stokes/#FE-spaces","page":"E3 transient navier stokes","title":"FE spaces","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/#Exercise-2","page":"E3 transient navier stokes","title":"Exercise 2","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"Define the test FE spaces for the velocity and pressure, using the same discretisations as in the previous exercise.","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"D = 2\nk = 2\n\n# reffeᵤ =\n# reffeₚ =\n# V =\n# Q =","category":"page"},{"location":"pages/E3_transient_navier_stokes/#Exercise-3","page":"E3 transient navier stokes","title":"Exercise 3","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"Define the boundary conditions for velocity. You should define three functions `uin,uwanduc` representing the prescribed dirichlet values at Gamma_in, Gamma_w and Gamma_c respectively._","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"const Tth = 2\nconst Uₘ = 1.5\nconst H  = 0.41\nξ(t) = (t <= Tth) ? sin(π*t/(2*Tth)) : 1.0\n# u_in(x,t::Real) =\n# u_w(x,t::Real)  =\n# u_c(x,t::Real)  =\nu_in(t::Real)   = x -> u_in(x,t)\nu_w(t::Real)    = x -> u_w(x,t)\nu_c(t::Real)    = x -> u_c(x,t)","category":"page"},{"location":"pages/E3_transient_navier_stokes/#Exercise-4","page":"E3 transient navier stokes","title":"Exercise 4","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"Define the trial and test spaces for the velocity and pressure fields, as well as the corresponding multi-field spaces.","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"# U =\n# P =\n# Y =\n# X =","category":"page"},{"location":"pages/E3_transient_navier_stokes/#Nonlinear-weak-form-and-FE-operator","page":"E3 transient navier stokes","title":"Nonlinear weak form and FE operator","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"As usual, we start by defining the triangulations and measures we will need to define the weak form. In this case, we need to define the measure associate with the bulk dOmega, as well as the measure associated with the outlet boundary Gamma_out.","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"degree = k\nΩ  = Triangulation(model)\ndΩ = Measure(Ω,degree)\n\nΓ_out = BoundaryTriangulation(model,tags=\"outlet\")\nn_Γout = get_normal_vector(Γ_out)\ndΓ_out = Measure(Γ_out,degree)","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"We also define the Reynolds number and functions to represent the convective term.","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"const Re = 100.0\nconv(u,∇u) = Re*(∇u')⋅u","category":"page"},{"location":"pages/E3_transient_navier_stokes/#Exercise-5","page":"E3 transient navier stokes","title":"Exercise 5","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"Define the residual r and the TransientFEOperator for our problem.","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"# m(t,(u,p),(v,q)) =\n# a(t,(u,p),(v,q)) =\n# c(u,v) =\n# res(t,(u,p),(v,q)) =\n\nop = TransientFEOperator(res,X,Y)","category":"page"},{"location":"pages/E3_transient_navier_stokes/#Solver-and-solution","page":"E3 transient navier stokes","title":"Solver and solution","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/#Exercise-6","page":"E3 transient navier stokes","title":"Exercise 6","text":"","category":"section"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"Create the ODE solver. In this exercise you should use the ThetaMethod with theta = 05 and a time step size Delta t = 001. Create a Newton-Raphson nonlinear solver to solve the nonlinear problem at each time step.","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"using LineSearches: BackTracking\nnls = NLSolver(show_trace=true, method=:newton, linesearch=BackTracking())\n\n# Δt =\n# θ  =\n# ode_solver =","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"We can then solve the problem and print the solutions as follows:","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"t₀ = 0.0\nT  = Tth\nu₀ = interpolate_everywhere([VectorValue(0.0,0.0),0.0],X(0.0))\nxₕₜ = solve(ode_solver,op,t₀,T,u₀)\n\ndir = datadir(\"ins_transient\")\n!isdir(dir) && mkdir(dir)\ncreatepvd(dir) do pvd\n  for (t,xₕ) in xₕₜ\n    println(\" > Computing solution at time $t\")\n    uₕ,pₕ = xₕ\n    file = dir*\"/solution_$t\"*\".vtu\"\n    pvd[t] = createvtk(Ω,file,cellfields=[\"u\"=>uₕ,\"p\"=>pₕ])\n  end\nend","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"","category":"page"},{"location":"pages/E3_transient_navier_stokes/","page":"E3 transient navier stokes","title":"E3 transient navier stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"going_further/#Going-further","page":"Going further","title":"Going further","text":"","category":"section"},{"location":"going_further/","page":"Going further","title":"Going further","text":"Due to time constraints, we have only been able to scratch the surface of what Gridap can do. This section provides additional resources and information for those who want to delve deeper into Gridap and its applications.","category":"page"},{"location":"going_further/","page":"Going further","title":"Going further","text":"More advanced tutorials can also be found in the Gridap Tutorials repository, which contains a wide range of examples and applications.","category":"page"},{"location":"going_further/#Distributed-computing-and-solvers","page":"Going further","title":"Distributed computing and solvers","text":"","category":"section"},{"location":"going_further/","page":"Going further","title":"Going further","text":"Gridap supports distributed computing through the GridapDistributed.jl. This package preserves (almost perfectly) the high-level interface of Gridap, allowing user to almost seamlessly parallelize their code accross multiple machines.","category":"page"},{"location":"going_further/","page":"Going further","title":"Going further","text":"When going to parallel, however, scalable solvers are required to preserve the performance of the code. Gridap provides many tools to deal with distributed linear systems:","category":"page"},{"location":"going_further/","page":"Going further","title":"Going further","text":"GridapSolvers.jl is our package for HPC solvers, built fully in Julia. See this tutorial. It provides:\nA collection of HPC-oriented preconditoned Krylov solvers.\nAn interface to design block-preconditioners.\nA GMG preconditioner, with a set of smoothers for H1, HDiv and HCurl type of problems. This also comes with a generic API to deal with multi-level solvers.\nGridapPETSc.jl is our interface to the PETSc library, which provides a wide range of solvers and preconditioners. These can also be used in conjunction with the block-preconditioners of GridapSolvers.jl. See this tutorial.","category":"page"},{"location":"going_further/#Embedded-methods","page":"Going further","title":"Embedded methods","text":"","category":"section"},{"location":"going_further/","page":"Going further","title":"Going further","text":"Embedded methods are a popular way of dealing with complex geometries. We provide a high order interface for these methods in the GridapEmbedded.jl package. This package allows you to define geometries using functions and level-sets. Support for STL meshes is provides in the satellite package STLCutters.jl. See this tutorial.","category":"page"},{"location":"going_further/#Hybrid-methods-and-polytopal-meshes","page":"Going further","title":"Hybrid methods and polytopal meshes","text":"","category":"section"},{"location":"going_further/","page":"Going further","title":"Going further","text":"Polytopal methods are another increasingly popular way of dealing with complex geometries. Recently, we have expanded the capabilities of Gridap towards hybrid non-confroming methods, such as HDG and HHO. This also include a high-level API to define and manipulate polytopal meshes. These functionalities are directly provided by Gridap.jl. We are planning to keep expanding these capabilities in the future, so stay tuned!","category":"page"},{"location":"going_further/#Adaptive-mesh-refinement","page":"Going further","title":"Adaptive mesh refinement","text":"","category":"section"},{"location":"going_further/","page":"Going further","title":"Going further","text":"Adaptive mesh refinement (AMR) is a powerful technique to improve the accuracy of numerical simulations by refining the mesh in regions where the solution is more complex. Gridap provides a high-level expandable API for refining and coarsening meshes, as well as support for AMR. See this tutorial. We also provide support for the well-known library p4est through the package GridapP4est.jl, which provides non-conforming highly efficient AMR on parallel distributed memory machines. See this tutorial.","category":"page"},{"location":"going_further/#Applications","page":"Going further","title":"Applications","text":"","category":"section"},{"location":"going_further/","page":"Going further","title":"Going further","text":"Some repositories providing more advanced applications using Gridap:","category":"page"},{"location":"going_further/","page":"Going further","title":"Going further","text":"Geosciences\nMagnetohydrodynamics\nTopology optimization","category":"page"},{"location":"#Introduction-to-Gridap:-Simulating-PDEs-using-finite-elements-in-Julia","page":"Introduction","title":"Introduction to Gridap: Simulating PDEs using finite elements in Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"🎉 Welcome to the webpage of Gridap's workshop at DD29!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Where? Room T01, Building 13, PoliMi Campus, Milan.\nWhen? Sunday 22nd June, 2025, 11.30-15 (with lunch break).","category":"page"},{"location":"#Workshop-description","page":"Introduction","title":"Workshop description","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This short workshop will showcase the main features of Gridap, an ecosystem of software packages for the simulation of problems governed by PDEs written in the Julia programming language.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Gridap has a very expressive user interface, allowing one to solve complex PDE systems by stating the problem using whiteboard notation. It implements multiple state-of-the-art finite element methods that can efficiently exploit large-scale HPC supercomputers.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The workshop will be tutorial-based and will cover the main features of Gridap and its application to several problems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The emphasis will be mainly on presenting the main software abstractions underlying these packages and how these can be combined to solve a variety of PDEs with application to different problems in science and engineering.  The choice of the PDE systems to be discussed in the workshop will be based on the participant's interests gathered during registration.  ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Participants must bring their own laptops. Instructions to install the software are available in Software installation. These should be followed before the actual workshop takes place.","category":"page"},{"location":"#Instructors","page":"Introduction","title":"Instructors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Prof. Santiago Badia - School of Mathematics, Faculty of Science, Monash University.\nMr. Jordi Manyer - School of Mathematics, Faculty of Science, Monash University.","category":"page"},{"location":"pages/E2_navier_stokes/#Problem-statement","page":"E2 navier stokes","title":"Problem statement","text":"","category":"section"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"The goal is to solve a nonlinear multi-field PDE. As a model problem, we consider a well known benchmark in computational fluid dynamics, the laminar flow around a cylinder for the incompressible Navier-Stokes equations. We will solve this problem by building on the concepts seen in the previous tutorials.","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"The computational domain Omega is a 2-dimensional channel. The fluid enters the channel from the left boundary (inlet) and exits through the right boundary (outlet). The channel has a cylindrical obstacle near the inlet. The domain can be seen in the following figure:","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"(Image: )","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"We define partial Omega = Gamma_w cup Gamma_c cup Gamma_in cup Gamma_out with Gamma_w the top and bottom channel walls, Gamma_c the cylinder walls, Gamma_in the inlet and Gamma_out the outlet.","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"Formally, the PDE we want to solve is: find the velocity vector u and the pressure p such that","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"leftlbrace\nbeginaligned\n-Delta u + mathitRe (ucdot nabla) u + nabla p = 0 text in Omega\nnablacdot u = 0 text in  Omega\nu = u_in text on  Gamma_in\nu = 0 text on  Gamma_w cup Gamma_c\nn_Gamma cdot sigma = 0 text on  Gamma_out\nendaligned\nright","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"where d=2 , and mathitRe is the Reynolds number.","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"The inflow condition is given by","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"u_in(0y) = left( 4 U_m fracy(H-y)H^2 0 right)","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"with U_m=03  ms the maximum velocity and H = 041  m the height of the channel.","category":"page"},{"location":"pages/E2_navier_stokes/#Numerical-Scheme","page":"E2 navier stokes","title":"Numerical Scheme","text":"","category":"section"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"In order to approximate this problem we choose a formulation based on inf-sup stable P_kP_k-1 triangular elements with continuous velocities and pressures. The interpolation spaces are defined as follows. The velocity interpolation space is","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"V doteq  v in H^1(Omega)^d v_Tin P_k(T)^d text for all  TinmathcalT ","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"where T denotes an arbitrary cell of the FE mesh mathcalT, and P_k(T) is the usual Lagrangian FE space of order k defined on a mesh of triangles or tetrahedra. On the other hand, the space for the pressure is given by","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"Q doteq  q in C^0(Omega) q_Tin P_k-1(T) text for all  TinmathcalT","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"The weak form associated to these interpolation spaces reads: find (up)in U_g times Q such that r(up)(vq)=0 for all (vq)in V_0 times Q where U_g and V_0 are the set of functions in V fulfilling the Dirichlet boundary conditions and the homogeneous Dirichlet boundary conditions respectively. The weak residual r evaluated at a given pair (up) is the linear form defined as","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"r(up)(vq) doteq a((up)(vq))+ c(u)(v)","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"with","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"beginaligned\na((up)(vq)) doteq int_Omega nabla v cdot nabla u  rm dOmega - int_Omega (nablacdot v)  p  rm dOmega + int_Omega q  (nabla cdot u)  rm dOmega\nc(u)(v) doteq int_Omega v \tcdot left( (ucdotnabla) u right) rm dOmega\nendaligned","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"Note that the bilinear form a is associated with the linear part of the PDE, whereas c is the contribution to the residual resulting from the convective term.","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"In order to solve this nonlinear weak equation with a Newton-Raphson method, one needs to compute the Jacobian associated with the residual r. In this case, the Jacobian j evaluated at a pair (up) is the bilinear form defined as","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"j(up)((delta u delta p)(vq)) doteq a((delta udelta p)(vq))  + rm dc(u)(delta uv)","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"where rm dc results from the linearization of the convective term, namely","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"rm dc(u)(delta uv) doteq int_Omega v cdot left( (ucdotnabla) delta u right)  rm dOmega + int_Omega v cdot left( (delta ucdotnabla) u right)   rm dOmega","category":"page"},{"location":"pages/E2_navier_stokes/#Geometry","page":"E2 navier stokes","title":"Geometry","text":"","category":"section"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"We start by importing the packages and loading the provided mesh in the file perforated_plate_tiny.msh:","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"using Gridap, GridapGmsh\nusing DrWatson\n\nmsh_file = projectdir(\"meshes/perforated_plate_tiny.msh\")\nmodel = GmshDiscreteModel(msh_file)","category":"page"},{"location":"pages/E2_navier_stokes/#Exercise-1","page":"E2 navier stokes","title":"Exercise 1","text":"","category":"section"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"Open the resulting files with ParaView. Visualize the faces of the model and color them by each of the available fields. Identify the tag names representing the boundaries \\Gamma{w}$ (top and bottom channel walls), Gamma_c (cylinder walls), Gamma_in (inlet) and Gamma_out (outlet)._","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"writevtk(model,datadir(\"perforated_plate\"))","category":"page"},{"location":"pages/E2_navier_stokes/#FE-Spaces","page":"E2 navier stokes","title":"FE Spaces","text":"","category":"section"},{"location":"pages/E2_navier_stokes/#Exercise-2","page":"E2 navier stokes","title":"Exercise 2","text":"","category":"section"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"Define the test FESpaces for velocity and pressure, as described above. The velocity space should be a vector-valued lagrangian space of order k with appropriate boundary conditions. The pressure space should be an unconstrained lagrangian space of order k-1.","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"D = 2\nk = 2","category":"page"},{"location":"pages/E2_navier_stokes/#Exercise-3","page":"E2 navier stokes","title":"Exercise 3","text":"","category":"section"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"Define the boundary conditions for velocity. You should define three functions `uin,uwanduc` representing the prescribed dirichlet values at Gamma_in, Gamma_w and Gamma_c respectively._","category":"page"},{"location":"pages/E2_navier_stokes/#Exercise-4","page":"E2 navier stokes","title":"Exercise 4","text":"","category":"section"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"Define the trial and test spaces for the velocity and pressure fields, as well as the corresponding multi-field spaces.","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"#U =\n#P =","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"#Y =\n#X =","category":"page"},{"location":"pages/E2_navier_stokes/#Nonlinear-weak-form-and-FE-operator","page":"E2 navier stokes","title":"Nonlinear weak form and FE operator","text":"","category":"section"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"As usual, we start by defining the triangulations and measures we will need to define the weak form. In this case, we need to define the measure associate with the bulk dOmega, as well as the measure associated with the outlet boundary Gamma_out.","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"degree = k\nΩ  = Triangulation(model)\ndΩ = Measure(Ω,degree)\n\nΓ_out = BoundaryTriangulation(model,tags=\"outlet\")\nn_Γout = get_normal_vector(Γ_out)\ndΓ_out = Measure(Γ_out,degree)","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"We also define the Reynolds number and functions to represent the convective term and its linearization.","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"const Re = 20\nconv(u,∇u) = Re*(∇u')⋅u\ndconv(du,∇du,u,∇u) = conv(u,∇du)+conv(du,∇u)","category":"page"},{"location":"pages/E2_navier_stokes/#Exercise-5","page":"E2 navier stokes","title":"Exercise 5","text":"","category":"section"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"Define the weak form for our problem. You should start by defining the bilinear forms a and c and the trilinear form dc. Then use these components to build the residual r and the jacobian j.","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"#a((u,p),(v,q)) =","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"#c(u,v) =\n#dc(u,du,v) =","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"#res((u,p),(v,q)) =\n#jac((u,p),(du,dp),(v,q)) =","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"We can finally define the FEOperator as usual","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"op = FEOperator(res,jac,X,Y)","category":"page"},{"location":"pages/E2_navier_stokes/#Solver-and-solution","page":"E2 navier stokes","title":"Solver and solution","text":"","category":"section"},{"location":"pages/E2_navier_stokes/#Exercise-6","page":"E2 navier stokes","title":"Exercise 6","text":"","category":"section"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"Create a nonlinear Newton-Raphson solver and solve the problem. Print the solutions to a .vtk file and examine the obtained solution.","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"using LineSearches: BackTracking","category":"page"},{"location":"pages/E2_navier_stokes/#References","page":"E2 navier stokes","title":"References","text":"","category":"section"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"This tutorial follows test case 2D-1 from (Schafer,1996)[https://link.springer.com/chapter/10.1007/978-3-322-89849-4_39]","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"","category":"page"},{"location":"pages/E2_navier_stokes/","page":"E2 navier stokes","title":"E2 navier stokes","text":"This page was generated using Literate.jl.","category":"page"}]
}
